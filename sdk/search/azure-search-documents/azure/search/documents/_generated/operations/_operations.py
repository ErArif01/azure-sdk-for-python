# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.2.1, generator: {generator})
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import sys
from typing import Any, Callable, Dict, IO, List, Optional, TypeVar, Union, cast, overload

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict

from .._serialization import Serializer
from .._vendor import _format_url_section

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
if sys.version_info >= (3, 8):
    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
else:
    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_documents_count_request(*, x_ms_client_request_id: Optional[str] = None, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop(
        "api_version", _params.pop("api-version", "2021-04-30-Preview")
    )  # type: Literal["2021-04-30-Preview"]
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/docs/$count"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if x_ms_client_request_id is not None:
        _headers["x-ms-client-request-id"] = _SERIALIZER.header("x_ms_client_request_id", x_ms_client_request_id, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_documents_search_get_request(
    *,
    search_text: Optional[str] = None,
    include_total_result_count: Optional[bool] = None,
    facets: Optional[List[str]] = None,
    filter: Optional[str] = None,
    highlight_fields: Optional[List[str]] = None,
    highlight_post_tag: Optional[str] = None,
    highlight_pre_tag: Optional[str] = None,
    minimum_coverage: Optional[float] = None,
    order_by: Optional[List[str]] = None,
    query_type: Optional[str] = None,
    scoring_parameters: Optional[List[str]] = None,
    scoring_profile: Optional[str] = None,
    semantic_configuration: Optional[str] = None,
    search_fields: Optional[List[str]] = None,
    query_language: Optional[str] = None,
    speller: Optional[str] = None,
    answers: Optional[str] = None,
    search_mode: Optional[str] = None,
    scoring_statistics: Optional[str] = None,
    session_id: Optional[str] = None,
    select: Optional[List[str]] = None,
    skip: Optional[int] = None,
    top: Optional[int] = None,
    captions: Optional[str] = None,
    semantic_fields: Optional[List[str]] = None,
    x_ms_client_request_id: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop(
        "api_version", _params.pop("api-version", "2021-04-30-Preview")
    )  # type: Literal["2021-04-30-Preview"]
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/docs"

    # Construct parameters
    if search_text is not None:
        _params["search"] = _SERIALIZER.query("search_text", search_text, "str")
    if include_total_result_count is not None:
        _params["$count"] = _SERIALIZER.query("include_total_result_count", include_total_result_count, "bool")
    if facets is not None:
        _params["facet"] = [_SERIALIZER.query("facets", q, "str") if q is not None else "" for q in facets]
    if filter is not None:
        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
    if highlight_fields is not None:
        _params["highlight"] = _SERIALIZER.query("highlight_fields", highlight_fields, "[str]", div=",")
    if highlight_post_tag is not None:
        _params["highlightPostTag"] = _SERIALIZER.query("highlight_post_tag", highlight_post_tag, "str")
    if highlight_pre_tag is not None:
        _params["highlightPreTag"] = _SERIALIZER.query("highlight_pre_tag", highlight_pre_tag, "str")
    if minimum_coverage is not None:
        _params["minimumCoverage"] = _SERIALIZER.query("minimum_coverage", minimum_coverage, "float")
    if order_by is not None:
        _params["$orderby"] = _SERIALIZER.query("order_by", order_by, "[str]", div=",")
    if query_type is not None:
        _params["queryType"] = _SERIALIZER.query("query_type", query_type, "str")
    if scoring_parameters is not None:
        _params["scoringParameter"] = [
            _SERIALIZER.query("scoring_parameters", q, "str") if q is not None else "" for q in scoring_parameters
        ]
    if scoring_profile is not None:
        _params["scoringProfile"] = _SERIALIZER.query("scoring_profile", scoring_profile, "str")
    if semantic_configuration is not None:
        _params["semanticConfiguration"] = _SERIALIZER.query("semantic_configuration", semantic_configuration, "str")
    if search_fields is not None:
        _params["searchFields"] = _SERIALIZER.query("search_fields", search_fields, "[str]", div=",")
    if query_language is not None:
        _params["queryLanguage"] = _SERIALIZER.query("query_language", query_language, "str")
    if speller is not None:
        _params["speller"] = _SERIALIZER.query("speller", speller, "str")
    if answers is not None:
        _params["answers"] = _SERIALIZER.query("answers", answers, "str")
    if search_mode is not None:
        _params["searchMode"] = _SERIALIZER.query("search_mode", search_mode, "str")
    if scoring_statistics is not None:
        _params["scoringStatistics"] = _SERIALIZER.query("scoring_statistics", scoring_statistics, "str")
    if session_id is not None:
        _params["sessionId"] = _SERIALIZER.query("session_id", session_id, "str")
    if select is not None:
        _params["$select"] = _SERIALIZER.query("select", select, "[str]", div=",")
    if skip is not None:
        _params["$skip"] = _SERIALIZER.query("skip", skip, "int")
    if top is not None:
        _params["$top"] = _SERIALIZER.query("top", top, "int")
    if captions is not None:
        _params["captions"] = _SERIALIZER.query("captions", captions, "str")
    if semantic_fields is not None:
        _params["semanticFields"] = _SERIALIZER.query("semantic_fields", semantic_fields, "[str]", div=",")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if x_ms_client_request_id is not None:
        _headers["x-ms-client-request-id"] = _SERIALIZER.header("x_ms_client_request_id", x_ms_client_request_id, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_documents_search_post_request(*, x_ms_client_request_id: Optional[str] = None, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop(
        "api_version", _params.pop("api-version", "2021-04-30-Preview")
    )  # type: Literal["2021-04-30-Preview"]
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/docs/search.post.search"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if x_ms_client_request_id is not None:
        _headers["x-ms-client-request-id"] = _SERIALIZER.header("x_ms_client_request_id", x_ms_client_request_id, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_documents_get_request(
    key: str,
    *,
    selected_fields: Optional[List[str]] = None,
    x_ms_client_request_id: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop(
        "api_version", _params.pop("api-version", "2021-04-30-Preview")
    )  # type: Literal["2021-04-30-Preview"]
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/docs('{key}')"
    path_format_arguments = {
        "key": _SERIALIZER.url("key", key, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if selected_fields is not None:
        _params["$select"] = _SERIALIZER.query("selected_fields", selected_fields, "[str]", div=",")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if x_ms_client_request_id is not None:
        _headers["x-ms-client-request-id"] = _SERIALIZER.header("x_ms_client_request_id", x_ms_client_request_id, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_documents_suggest_get_request(
    *,
    search_text: str,
    suggester_name: str,
    filter: Optional[str] = None,
    use_fuzzy_matching: Optional[bool] = None,
    highlight_post_tag: Optional[str] = None,
    highlight_pre_tag: Optional[str] = None,
    minimum_coverage: Optional[float] = None,
    order_by: Optional[List[str]] = None,
    search_fields: Optional[List[str]] = None,
    select: Optional[List[str]] = None,
    top: Optional[int] = None,
    x_ms_client_request_id: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop(
        "api_version", _params.pop("api-version", "2021-04-30-Preview")
    )  # type: Literal["2021-04-30-Preview"]
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/docs/search.suggest"

    # Construct parameters
    _params["search"] = _SERIALIZER.query("search_text", search_text, "str")
    _params["suggesterName"] = _SERIALIZER.query("suggester_name", suggester_name, "str")
    if filter is not None:
        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
    if use_fuzzy_matching is not None:
        _params["fuzzy"] = _SERIALIZER.query("use_fuzzy_matching", use_fuzzy_matching, "bool")
    if highlight_post_tag is not None:
        _params["highlightPostTag"] = _SERIALIZER.query("highlight_post_tag", highlight_post_tag, "str")
    if highlight_pre_tag is not None:
        _params["highlightPreTag"] = _SERIALIZER.query("highlight_pre_tag", highlight_pre_tag, "str")
    if minimum_coverage is not None:
        _params["minimumCoverage"] = _SERIALIZER.query("minimum_coverage", minimum_coverage, "float")
    if order_by is not None:
        _params["$orderby"] = _SERIALIZER.query("order_by", order_by, "[str]", div=",")
    if search_fields is not None:
        _params["searchFields"] = _SERIALIZER.query("search_fields", search_fields, "[str]", div=",")
    if select is not None:
        _params["$select"] = _SERIALIZER.query("select", select, "[str]", div=",")
    if top is not None:
        _params["$top"] = _SERIALIZER.query("top", top, "int")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if x_ms_client_request_id is not None:
        _headers["x-ms-client-request-id"] = _SERIALIZER.header("x_ms_client_request_id", x_ms_client_request_id, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_documents_suggest_post_request(*, x_ms_client_request_id: Optional[str] = None, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop(
        "api_version", _params.pop("api-version", "2021-04-30-Preview")
    )  # type: Literal["2021-04-30-Preview"]
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/docs/search.post.suggest"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if x_ms_client_request_id is not None:
        _headers["x-ms-client-request-id"] = _SERIALIZER.header("x_ms_client_request_id", x_ms_client_request_id, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_documents_index_request(*, x_ms_client_request_id: Optional[str] = None, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop(
        "api_version", _params.pop("api-version", "2021-04-30-Preview")
    )  # type: Literal["2021-04-30-Preview"]
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/docs/search.index"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if x_ms_client_request_id is not None:
        _headers["x-ms-client-request-id"] = _SERIALIZER.header("x_ms_client_request_id", x_ms_client_request_id, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_documents_autocomplete_get_request(
    *,
    search_text: str,
    suggester_name: str,
    x_ms_client_request_id: Optional[str] = None,
    autocomplete_mode: Optional[str] = None,
    filter: Optional[str] = None,
    use_fuzzy_matching: Optional[bool] = None,
    highlight_post_tag: Optional[str] = None,
    highlight_pre_tag: Optional[str] = None,
    minimum_coverage: Optional[float] = None,
    search_fields: Optional[List[str]] = None,
    top: Optional[int] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop(
        "api_version", _params.pop("api-version", "2021-04-30-Preview")
    )  # type: Literal["2021-04-30-Preview"]
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/docs/search.autocomplete"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    _params["search"] = _SERIALIZER.query("search_text", search_text, "str")
    _params["suggesterName"] = _SERIALIZER.query("suggester_name", suggester_name, "str")
    if autocomplete_mode is not None:
        _params["autocompleteMode"] = _SERIALIZER.query("autocomplete_mode", autocomplete_mode, "str")
    if filter is not None:
        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
    if use_fuzzy_matching is not None:
        _params["fuzzy"] = _SERIALIZER.query("use_fuzzy_matching", use_fuzzy_matching, "bool")
    if highlight_post_tag is not None:
        _params["highlightPostTag"] = _SERIALIZER.query("highlight_post_tag", highlight_post_tag, "str")
    if highlight_pre_tag is not None:
        _params["highlightPreTag"] = _SERIALIZER.query("highlight_pre_tag", highlight_pre_tag, "str")
    if minimum_coverage is not None:
        _params["minimumCoverage"] = _SERIALIZER.query("minimum_coverage", minimum_coverage, "float")
    if search_fields is not None:
        _params["searchFields"] = _SERIALIZER.query("search_fields", search_fields, "[str]", div=",")
    if top is not None:
        _params["$top"] = _SERIALIZER.query("top", top, "int")

    # Construct headers
    if x_ms_client_request_id is not None:
        _headers["x-ms-client-request-id"] = _SERIALIZER.header("x_ms_client_request_id", x_ms_client_request_id, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_documents_autocomplete_post_request(
    *, x_ms_client_request_id: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop(
        "api_version", _params.pop("api-version", "2021-04-30-Preview")
    )  # type: Literal["2021-04-30-Preview"]
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/docs/search.post.autocomplete"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if x_ms_client_request_id is not None:
        _headers["x-ms-client-request-id"] = _SERIALIZER.header("x_ms_client_request_id", x_ms_client_request_id, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


class DocumentsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~search_index_client.SearchIndexClient`'s
        :attr:`documents` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def count(self, *, x_ms_client_request_id: Optional[str] = None, **kwargs: Any) -> int:
        """Queries the number of documents in the index.

        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :return: int
        :rtype: int
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[int]

        request = build_documents_count_request(
            x_ms_client_request_id=x_ms_client_request_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "indexName": self._serialize.url("self._config.index_name", self._config.index_name, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(int, deserialized), {})

        return cast(int, deserialized)

    @distributed_trace
    def search_get(
        self,
        *,
        search_text: Optional[str] = None,
        include_total_result_count: Optional[bool] = None,
        facets: Optional[List[str]] = None,
        filter: Optional[str] = None,
        highlight_fields: Optional[List[str]] = None,
        highlight_post_tag: Optional[str] = None,
        highlight_pre_tag: Optional[str] = None,
        minimum_coverage: Optional[float] = None,
        order_by: Optional[List[str]] = None,
        query_type: Optional[str] = None,
        scoring_parameters: Optional[List[str]] = None,
        scoring_profile: Optional[str] = None,
        semantic_configuration: Optional[str] = None,
        search_fields: Optional[List[str]] = None,
        query_language: Optional[str] = None,
        speller: Optional[str] = None,
        answers: Optional[str] = None,
        search_mode: Optional[str] = None,
        scoring_statistics: Optional[str] = None,
        session_id: Optional[str] = None,
        select: Optional[List[str]] = None,
        skip: Optional[int] = None,
        top: Optional[int] = None,
        captions: Optional[str] = None,
        semantic_fields: Optional[List[str]] = None,
        x_ms_client_request_id: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """Searches for documents in the index.

        :keyword search_text: A full-text search query expression; Use "*" or omit this parameter to
         match all documents. Default value is None.
        :paramtype search_text: str
        :keyword include_total_result_count: A value that specifies whether to fetch the total count of
         results. Default is false. Setting this value to true may have a performance impact. Note that
         the count returned is an approximation. Default value is None.
        :paramtype include_total_result_count: bool
        :keyword facets: The list of facet expressions to apply to the search query. Each facet
         expression contains a field name, optionally followed by a comma-separated list of name:value
         pairs. Default value is None.
        :paramtype facets: list[str]
        :keyword filter: The OData $filter expression to apply to the search query. Default value is
         None.
        :paramtype filter: str
        :keyword highlight_fields: The list of field names to use for hit highlights. Only searchable
         fields can be used for hit highlighting. Default value is None.
        :paramtype highlight_fields: list[str]
        :keyword highlight_post_tag: A string tag that is appended to hit highlights. Must be set with
         highlightPreTag. Default is &lt;/em&gt;. Default value is None.
        :paramtype highlight_post_tag: str
        :keyword highlight_pre_tag: A string tag that is prepended to hit highlights. Must be set with
         highlightPostTag. Default is &lt;em&gt;. Default value is None.
        :paramtype highlight_pre_tag: str
        :keyword minimum_coverage: A number between 0 and 100 indicating the percentage of the index
         that must be covered by a search query in order for the query to be reported as a success. This
         parameter can be useful for ensuring search availability even for services with only one
         replica. The default is 100. Default value is None.
        :paramtype minimum_coverage: float
        :keyword order_by: The list of OData $orderby expressions by which to sort the results. Each
         expression can be either a field name or a call to either the geo.distance() or the
         search.score() functions. Each expression can be followed by asc to indicate ascending, and
         desc to indicate descending. The default is ascending order. Ties will be broken by the match
         scores of documents. If no OrderBy is specified, the default sort order is descending by
         document match score. There can be at most 32 $orderby clauses. Default value is None.
        :paramtype order_by: list[str]
        :keyword query_type: A value that specifies the syntax of the search query. The default is
         'simple'. Use 'full' if your query uses the Lucene query syntax. Known values are: "simple",
         "full", and "semantic". Default value is None.
        :paramtype query_type: str
        :keyword scoring_parameters: The list of parameter values to be used in scoring functions (for
         example, referencePointParameter) using the format name-values. For example, if the scoring
         profile defines a function with a parameter called 'mylocation' the parameter string would be
         "mylocation--122.2,44.8" (without the quotes). Default value is None.
        :paramtype scoring_parameters: list[str]
        :keyword scoring_profile: The name of a scoring profile to evaluate match scores for matching
         documents in order to sort the results. Default value is None.
        :paramtype scoring_profile: str
        :keyword semantic_configuration: The name of the semantic configuration that lists which fields
         should be used for semantic ranking, captions, highlights, and answers. Default value is None.
        :paramtype semantic_configuration: str
        :keyword search_fields: The list of field names to which to scope the full-text search. When
         using fielded search (fieldName:searchExpression) in a full Lucene query, the field names of
         each fielded search expression take precedence over any field names listed in this parameter.
         Default value is None.
        :paramtype search_fields: list[str]
        :keyword query_language: The language of the query. Known values are: "none", "en-us", "en-gb",
         "en-in", "en-ca", "en-au", "fr-fr", "fr-ca", "de-de", "es-es", "es-mx", "zh-cn", "zh-tw",
         "pt-br", "pt-pt", "it-it", "ja-jp", "ko-kr", "ru-ru", "cs-cz", "nl-be", "nl-nl", "hu-hu",
         "pl-pl", "sv-se", "tr-tr", "hi-in", "ar-sa", "ar-eg", "ar-ma", "ar-kw", "ar-jo", "da-dk",
         "no-no", "bg-bg", "hr-hr", "hr-ba", "ms-my", "ms-bn", "sl-sl", "ta-in", "vi-vn", "el-gr",
         "ro-ro", "is-is", "id-id", "th-th", "lt-lt", "uk-ua", "lv-lv", "et-ee", "ca-es", "fi-fi",
         "sr-ba", "sr-me", "sr-rs", "sk-sk", "nb-no", "hy-am", "bn-in", "eu-es", "gl-es", "gu-in",
         "he-il", "ga-ie", "kn-in", "ml-in", "mr-in", "fa-ae", "pa-in", "te-in", and "ur-pk". Default
         value is None.
        :paramtype query_language: str
        :keyword speller: Improve search recall by spell-correcting individual search query terms.
         Known values are: "none" and "lexicon". Default value is None.
        :paramtype speller: str
        :keyword answers: This parameter is only valid if the query type is 'semantic'. If set, the
         query returns answers extracted from key passages in the highest ranked documents. The number
         of answers returned can be configured by appending the pipe character '|' followed by the
         'count-:code:`<number of answers>`' option after the answers parameter value, such as
         'extractive|count-3'. Default count is 1. Known values are: "none" and "extractive". Default
         value is None.
        :paramtype answers: str
        :keyword search_mode: A value that specifies whether any or all of the search terms must be
         matched in order to count the document as a match. Known values are: "any" and "all". Default
         value is None.
        :paramtype search_mode: str
        :keyword scoring_statistics: A value that specifies whether we want to calculate scoring
         statistics (such as document frequency) globally for more consistent scoring, or locally, for
         lower latency. Known values are: "local" and "global". Default value is None.
        :paramtype scoring_statistics: str
        :keyword session_id: A value to be used to create a sticky session, which can help to get more
         consistent results. As long as the same sessionId is used, a best-effort attempt will be made
         to target the same replica set. Be wary that reusing the same sessionID values repeatedly can
         interfere with the load balancing of the requests across replicas and adversely affect the
         performance of the search service. The value used as sessionId cannot start with a '_'
         character. Default value is None.
        :paramtype session_id: str
        :keyword select: The list of fields to retrieve. If unspecified, all fields marked as
         retrievable in the schema are included. Default value is None.
        :paramtype select: list[str]
        :keyword skip: The number of search results to skip. This value cannot be greater than 100,000.
         If you need to scan documents in sequence, but cannot use $skip due to this limitation,
         consider using $orderby on a totally-ordered key and $filter with a range query instead.
         Default value is None.
        :paramtype skip: int
        :keyword top: The number of search results to retrieve. This can be used in conjunction with
         $skip to implement client-side paging of search results. If results are truncated due to
         server-side paging, the response will include a continuation token that can be used to issue
         another Search request for the next page of results. Default value is None.
        :paramtype top: int
        :keyword captions: This parameter is only valid if the query type is 'semantic'. If set, the
         query returns captions extracted from key passages in the highest ranked documents. When
         Captions is set to 'extractive', highlighting is enabled by default, and can be configured by
         appending the pipe character '|' followed by the 'highlight-<true/false>' option, such as
         'extractive|highlight-true'. Defaults to 'None'. Known values are: "none" and "extractive".
         Default value is None.
        :paramtype captions: str
        :keyword semantic_fields: The list of field names used for semantic search. Default value is
         None.
        :paramtype semantic_fields: list[str]
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "@search.score": 0.0,  # The relevance score of the document
                              compared to other documents returned by the query. Required.
                            "@search.captions": [
                                {
                                    "highlights": "str",  # Optional. Same text
                                      passage as in the Text property with highlighted phrases most
                                      relevant to the query.
                                    "text": "str"  # Optional. A representative
                                      text passage extracted from the document most relevant to the
                                      search query.
                                }
                            ],
                            "@search.highlights": {
                                "str": [
                                    "str"  # Optional. Text fragments from the
                                      document that indicate the matching search terms, organized by
                                      each applicable field; null if hit highlighting was not enabled
                                      for the query.
                                ]
                            },
                            "@search.rerankerScore": 0.0  # Optional. The relevance score
                              computed by the semantic ranker for the top search results. Search
                              results are sorted by the RerankerScore first and then by the Score.
                              RerankerScore is only returned for queries of type 'semantic'.
                        }
                    ],
                    "@odata.count": 0,  # Optional. The total count of results found by the
                      search operation, or null if the count was not requested. If present, the count
                      may be greater than the number of results in this response. This can happen if
                      you use the $top or $skip parameters, or if Azure Cognitive Search can't return
                      all the requested documents in a single Search response.
                    "@odata.nextLink": "str",  # Optional. Continuation URL returned when Azure
                      Cognitive Search can't return all the requested results in a single Search
                      response. You can use this URL to formulate another GET or POST Search request to
                      get the next part of the search response. Make sure to use the same verb (GET or
                      POST) as the request that produced this response.
                    "@search.answers": [
                        {
                            "highlights": "str",  # Optional. Same text passage as in the
                              Text property with highlighted text phrases most relevant to the query.
                            "key": "str",  # Optional. The key of the document the answer
                              was extracted from.
                            "score": 0.0,  # Optional. The score value represents how
                              relevant the answer is to the query relative to other answers returned
                              for the query.
                            "text": "str"  # Optional. The text passage extracted from
                              the document contents as the answer.
                        }
                    ],
                    "@search.coverage": 0.0,  # Optional. A value indicating the percentage of
                      the index that was included in the query, or null if minimumCoverage was not
                      specified in the request.
                    "@search.facets": {
                        "str": [
                            {
                                "count": 0  # Optional. The approximate count of
                                  documents falling within the bucket described by this facet.
                            }
                        ]
                    },
                    "@search.nextPageParameters": {
                        "answers": "str",  # Optional. A value that specifies whether answers
                          should be returned as part of the search response. Known values are: "none"
                          and "extractive".
                        "captions": "str",  # Optional. A value that specifies whether
                          captions should be returned as part of the search response. Known values are:
                          "none" and "extractive".
                        "count": bool,  # Optional. A value that specifies whether to fetch
                          the total count of results. Default is false. Setting this value to true may
                          have a performance impact. Note that the count returned is an approximation.
                        "facets": [
                            "str"  # Optional. The list of facet expressions to apply to
                              the search query. Each facet expression contains a field name, optionally
                              followed by a comma-separated list of name:value pairs.
                        ],
                        "filter": "str",  # Optional. The OData $filter expression to apply
                          to the search query.
                        "highlight": "str",  # Optional. The comma-separated list of field
                          names to use for hit highlights. Only searchable fields can be used for hit
                          highlighting.
                        "highlightPostTag": "str",  # Optional. A string tag that is appended
                          to hit highlights. Must be set with highlightPreTag. Default is &lt;/em&gt;.
                        "highlightPreTag": "str",  # Optional. A string tag that is prepended
                          to hit highlights. Must be set with highlightPostTag. Default is &lt;em&gt;.
                        "minimumCoverage": 0.0,  # Optional. A number between 0 and 100
                          indicating the percentage of the index that must be covered by a search query
                          in order for the query to be reported as a success. This parameter can be
                          useful for ensuring search availability even for services with only one
                          replica. The default is 100.
                        "orderby": "str",  # Optional. The comma-separated list of OData
                          $orderby expressions by which to sort the results. Each expression can be
                          either a field name or a call to either the geo.distance() or the
                          search.score() functions. Each expression can be followed by asc to indicate
                          ascending, or desc to indicate descending. The default is ascending order.
                          Ties will be broken by the match scores of documents. If no $orderby is
                          specified, the default sort order is descending by document match score.
                          There can be at most 32 $orderby clauses.
                        "queryLanguage": "str",  # Optional. A value that specifies the
                          language of the search query. Known values are: "none", "en-us", "en-gb",
                          "en-in", "en-ca", "en-au", "fr-fr", "fr-ca", "de-de", "es-es", "es-mx",
                          "zh-cn", "zh-tw", "pt-br", "pt-pt", "it-it", "ja-jp", "ko-kr", "ru-ru",
                          "cs-cz", "nl-be", "nl-nl", "hu-hu", "pl-pl", "sv-se", "tr-tr", "hi-in",
                          "ar-sa", "ar-eg", "ar-ma", "ar-kw", "ar-jo", "da-dk", "no-no", "bg-bg",
                          "hr-hr", "hr-ba", "ms-my", "ms-bn", "sl-sl", "ta-in", "vi-vn", "el-gr",
                          "ro-ro", "is-is", "id-id", "th-th", "lt-lt", "uk-ua", "lv-lv", "et-ee",
                          "ca-es", "fi-fi", "sr-ba", "sr-me", "sr-rs", "sk-sk", "nb-no", "hy-am",
                          "bn-in", "eu-es", "gl-es", "gu-in", "he-il", "ga-ie", "kn-in", "ml-in",
                          "mr-in", "fa-ae", "pa-in", "te-in", and "ur-pk".
                        "queryType": "str",  # Optional. A value that specifies the syntax of
                          the search query. The default is 'simple'. Use 'full' if your query uses the
                          Lucene query syntax. Known values are: "simple", "full", and "semantic".
                        "scoringParameters": [
                            "str"  # Optional. The list of parameter values to be used in
                              scoring functions (for example, referencePointParameter) using the format
                              name-values. For example, if the scoring profile defines a function with
                              a parameter called 'mylocation' the parameter string would be
                              "mylocation--122.2,44.8" (without the quotes).
                        ],
                        "scoringProfile": "str",  # Optional. The name of a scoring profile
                          to evaluate match scores for matching documents in order to sort the results.
                        "scoringStatistics": "str",  # Optional. A value that specifies
                          whether we want to calculate scoring statistics (such as document frequency)
                          globally for more consistent scoring, or locally, for lower latency. The
                          default is 'local'. Use 'global' to aggregate scoring statistics globally
                          before scoring. Using global scoring statistics can increase latency of
                          search queries. Known values are: "local" and "global".
                        "search": "str",  # Optional. A full-text search query expression;
                          Use "*" or omit this parameter to match all documents.
                        "searchFields": "str",  # Optional. The comma-separated list of field
                          names to which to scope the full-text search. When using fielded search
                          (fieldName:searchExpression) in a full Lucene query, the field names of each
                          fielded search expression take precedence over any field names listed in this
                          parameter.
                        "searchMode": "str",  # Optional. A value that specifies whether any
                          or all of the search terms must be matched in order to count the document as
                          a match. Known values are: "any" and "all".
                        "select": "str",  # Optional. The comma-separated list of fields to
                          retrieve. If unspecified, all fields marked as retrievable in the schema are
                          included.
                        "semanticConfiguration": "str",  # Optional. The name of a semantic
                          configuration that will be used when processing documents for queries of type
                          semantic.
                        "semanticFields": "str",  # Optional. The comma-separated list of
                          field names used for semantic search.
                        "sessionId": "str",  # Optional. A value to be used to create a
                          sticky session, which can help getting more consistent results. As long as
                          the same sessionId is used, a best-effort attempt will be made to target the
                          same replica set. Be wary that reusing the same sessionID values repeatedly
                          can interfere with the load balancing of the requests across replicas and
                          adversely affect the performance of the search service. The value used as
                          sessionId cannot start with a '_' character.
                        "skip": 0,  # Optional. The number of search results to skip. This
                          value cannot be greater than 100,000. If you need to scan documents in
                          sequence, but cannot use skip due to this limitation, consider using orderby
                          on a totally-ordered key and filter with a range query instead.
                        "speller": "str",  # Optional. A value that specified the type of the
                          speller to use to spell-correct individual search query terms. Known values
                          are: "none" and "lexicon".
                        "top": 0  # Optional. The number of search results to retrieve. This
                          can be used in conjunction with $skip to implement client-side paging of
                          search results. If results are truncated due to server-side paging, the
                          response will include a continuation token that can be used to issue another
                          Search request for the next page of results.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_documents_search_get_request(
            search_text=search_text,
            include_total_result_count=include_total_result_count,
            facets=facets,
            filter=filter,
            highlight_fields=highlight_fields,
            highlight_post_tag=highlight_post_tag,
            highlight_pre_tag=highlight_pre_tag,
            minimum_coverage=minimum_coverage,
            order_by=order_by,
            query_type=query_type,
            scoring_parameters=scoring_parameters,
            scoring_profile=scoring_profile,
            semantic_configuration=semantic_configuration,
            search_fields=search_fields,
            query_language=query_language,
            speller=speller,
            answers=answers,
            search_mode=search_mode,
            scoring_statistics=scoring_statistics,
            session_id=session_id,
            select=select,
            skip=skip,
            top=top,
            captions=captions,
            semantic_fields=semantic_fields,
            x_ms_client_request_id=x_ms_client_request_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "indexName": self._serialize.url("self._config.index_name", self._config.index_name, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def search_post(
        self,
        search_request: JSON,
        *,
        x_ms_client_request_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Searches for documents in the index.

        :param search_request: The definition of the Search request. Required.
        :type search_request: JSON
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                search_request = {
                    "answers": "str",  # Optional. A value that specifies whether answers should
                      be returned as part of the search response. Known values are: "none" and
                      "extractive".
                    "captions": "str",  # Optional. A value that specifies whether captions
                      should be returned as part of the search response. Known values are: "none" and
                      "extractive".
                    "count": bool,  # Optional. A value that specifies whether to fetch the total
                      count of results. Default is false. Setting this value to true may have a
                      performance impact. Note that the count returned is an approximation.
                    "facets": [
                        "str"  # Optional. The list of facet expressions to apply to the
                          search query. Each facet expression contains a field name, optionally
                          followed by a comma-separated list of name:value pairs.
                    ],
                    "filter": "str",  # Optional. The OData $filter expression to apply to the
                      search query.
                    "highlight": "str",  # Optional. The comma-separated list of field names to
                      use for hit highlights. Only searchable fields can be used for hit highlighting.
                    "highlightPostTag": "str",  # Optional. A string tag that is appended to hit
                      highlights. Must be set with highlightPreTag. Default is &lt;/em&gt;.
                    "highlightPreTag": "str",  # Optional. A string tag that is prepended to hit
                      highlights. Must be set with highlightPostTag. Default is &lt;em&gt;.
                    "minimumCoverage": 0.0,  # Optional. A number between 0 and 100 indicating
                      the percentage of the index that must be covered by a search query in order for
                      the query to be reported as a success. This parameter can be useful for ensuring
                      search availability even for services with only one replica. The default is 100.
                    "orderby": "str",  # Optional. The comma-separated list of OData $orderby
                      expressions by which to sort the results. Each expression can be either a field
                      name or a call to either the geo.distance() or the search.score() functions. Each
                      expression can be followed by asc to indicate ascending, or desc to indicate
                      descending. The default is ascending order. Ties will be broken by the match
                      scores of documents. If no $orderby is specified, the default sort order is
                      descending by document match score. There can be at most 32 $orderby clauses.
                    "queryLanguage": "str",  # Optional. A value that specifies the language of
                      the search query. Known values are: "none", "en-us", "en-gb", "en-in", "en-ca",
                      "en-au", "fr-fr", "fr-ca", "de-de", "es-es", "es-mx", "zh-cn", "zh-tw", "pt-br",
                      "pt-pt", "it-it", "ja-jp", "ko-kr", "ru-ru", "cs-cz", "nl-be", "nl-nl", "hu-hu",
                      "pl-pl", "sv-se", "tr-tr", "hi-in", "ar-sa", "ar-eg", "ar-ma", "ar-kw", "ar-jo",
                      "da-dk", "no-no", "bg-bg", "hr-hr", "hr-ba", "ms-my", "ms-bn", "sl-sl", "ta-in",
                      "vi-vn", "el-gr", "ro-ro", "is-is", "id-id", "th-th", "lt-lt", "uk-ua", "lv-lv",
                      "et-ee", "ca-es", "fi-fi", "sr-ba", "sr-me", "sr-rs", "sk-sk", "nb-no", "hy-am",
                      "bn-in", "eu-es", "gl-es", "gu-in", "he-il", "ga-ie", "kn-in", "ml-in", "mr-in",
                      "fa-ae", "pa-in", "te-in", and "ur-pk".
                    "queryType": "str",  # Optional. A value that specifies the syntax of the
                      search query. The default is 'simple'. Use 'full' if your query uses the Lucene
                      query syntax. Known values are: "simple", "full", and "semantic".
                    "scoringParameters": [
                        "str"  # Optional. The list of parameter values to be used in scoring
                          functions (for example, referencePointParameter) using the format
                          name-values. For example, if the scoring profile defines a function with a
                          parameter called 'mylocation' the parameter string would be
                          "mylocation--122.2,44.8" (without the quotes).
                    ],
                    "scoringProfile": "str",  # Optional. The name of a scoring profile to
                      evaluate match scores for matching documents in order to sort the results.
                    "scoringStatistics": "str",  # Optional. A value that specifies whether we
                      want to calculate scoring statistics (such as document frequency) globally for
                      more consistent scoring, or locally, for lower latency. The default is 'local'.
                      Use 'global' to aggregate scoring statistics globally before scoring. Using
                      global scoring statistics can increase latency of search queries. Known values
                      are: "local" and "global".
                    "search": "str",  # Optional. A full-text search query expression; Use "*" or
                      omit this parameter to match all documents.
                    "searchFields": "str",  # Optional. The comma-separated list of field names
                      to which to scope the full-text search. When using fielded search
                      (fieldName:searchExpression) in a full Lucene query, the field names of each
                      fielded search expression take precedence over any field names listed in this
                      parameter.
                    "searchMode": "str",  # Optional. A value that specifies whether any or all
                      of the search terms must be matched in order to count the document as a match.
                      Known values are: "any" and "all".
                    "select": "str",  # Optional. The comma-separated list of fields to retrieve.
                      If unspecified, all fields marked as retrievable in the schema are included.
                    "semanticConfiguration": "str",  # Optional. The name of a semantic
                      configuration that will be used when processing documents for queries of type
                      semantic.
                    "semanticFields": "str",  # Optional. The comma-separated list of field names
                      used for semantic search.
                    "sessionId": "str",  # Optional. A value to be used to create a sticky
                      session, which can help getting more consistent results. As long as the same
                      sessionId is used, a best-effort attempt will be made to target the same replica
                      set. Be wary that reusing the same sessionID values repeatedly can interfere with
                      the load balancing of the requests across replicas and adversely affect the
                      performance of the search service. The value used as sessionId cannot start with
                      a '_' character.
                    "skip": 0,  # Optional. The number of search results to skip. This value
                      cannot be greater than 100,000. If you need to scan documents in sequence, but
                      cannot use skip due to this limitation, consider using orderby on a
                      totally-ordered key and filter with a range query instead.
                    "speller": "str",  # Optional. A value that specified the type of the speller
                      to use to spell-correct individual search query terms. Known values are: "none"
                      and "lexicon".
                    "top": 0  # Optional. The number of search results to retrieve. This can be
                      used in conjunction with $skip to implement client-side paging of search results.
                      If results are truncated due to server-side paging, the response will include a
                      continuation token that can be used to issue another Search request for the next
                      page of results.
                }

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "@search.score": 0.0,  # The relevance score of the document
                              compared to other documents returned by the query. Required.
                            "@search.captions": [
                                {
                                    "highlights": "str",  # Optional. Same text
                                      passage as in the Text property with highlighted phrases most
                                      relevant to the query.
                                    "text": "str"  # Optional. A representative
                                      text passage extracted from the document most relevant to the
                                      search query.
                                }
                            ],
                            "@search.highlights": {
                                "str": [
                                    "str"  # Optional. Text fragments from the
                                      document that indicate the matching search terms, organized by
                                      each applicable field; null if hit highlighting was not enabled
                                      for the query.
                                ]
                            },
                            "@search.rerankerScore": 0.0  # Optional. The relevance score
                              computed by the semantic ranker for the top search results. Search
                              results are sorted by the RerankerScore first and then by the Score.
                              RerankerScore is only returned for queries of type 'semantic'.
                        }
                    ],
                    "@odata.count": 0,  # Optional. The total count of results found by the
                      search operation, or null if the count was not requested. If present, the count
                      may be greater than the number of results in this response. This can happen if
                      you use the $top or $skip parameters, or if Azure Cognitive Search can't return
                      all the requested documents in a single Search response.
                    "@odata.nextLink": "str",  # Optional. Continuation URL returned when Azure
                      Cognitive Search can't return all the requested results in a single Search
                      response. You can use this URL to formulate another GET or POST Search request to
                      get the next part of the search response. Make sure to use the same verb (GET or
                      POST) as the request that produced this response.
                    "@search.answers": [
                        {
                            "highlights": "str",  # Optional. Same text passage as in the
                              Text property with highlighted text phrases most relevant to the query.
                            "key": "str",  # Optional. The key of the document the answer
                              was extracted from.
                            "score": 0.0,  # Optional. The score value represents how
                              relevant the answer is to the query relative to other answers returned
                              for the query.
                            "text": "str"  # Optional. The text passage extracted from
                              the document contents as the answer.
                        }
                    ],
                    "@search.coverage": 0.0,  # Optional. A value indicating the percentage of
                      the index that was included in the query, or null if minimumCoverage was not
                      specified in the request.
                    "@search.facets": {
                        "str": [
                            {
                                "count": 0  # Optional. The approximate count of
                                  documents falling within the bucket described by this facet.
                            }
                        ]
                    },
                    "@search.nextPageParameters": {
                        "answers": "str",  # Optional. A value that specifies whether answers
                          should be returned as part of the search response. Known values are: "none"
                          and "extractive".
                        "captions": "str",  # Optional. A value that specifies whether
                          captions should be returned as part of the search response. Known values are:
                          "none" and "extractive".
                        "count": bool,  # Optional. A value that specifies whether to fetch
                          the total count of results. Default is false. Setting this value to true may
                          have a performance impact. Note that the count returned is an approximation.
                        "facets": [
                            "str"  # Optional. The list of facet expressions to apply to
                              the search query. Each facet expression contains a field name, optionally
                              followed by a comma-separated list of name:value pairs.
                        ],
                        "filter": "str",  # Optional. The OData $filter expression to apply
                          to the search query.
                        "highlight": "str",  # Optional. The comma-separated list of field
                          names to use for hit highlights. Only searchable fields can be used for hit
                          highlighting.
                        "highlightPostTag": "str",  # Optional. A string tag that is appended
                          to hit highlights. Must be set with highlightPreTag. Default is &lt;/em&gt;.
                        "highlightPreTag": "str",  # Optional. A string tag that is prepended
                          to hit highlights. Must be set with highlightPostTag. Default is &lt;em&gt;.
                        "minimumCoverage": 0.0,  # Optional. A number between 0 and 100
                          indicating the percentage of the index that must be covered by a search query
                          in order for the query to be reported as a success. This parameter can be
                          useful for ensuring search availability even for services with only one
                          replica. The default is 100.
                        "orderby": "str",  # Optional. The comma-separated list of OData
                          $orderby expressions by which to sort the results. Each expression can be
                          either a field name or a call to either the geo.distance() or the
                          search.score() functions. Each expression can be followed by asc to indicate
                          ascending, or desc to indicate descending. The default is ascending order.
                          Ties will be broken by the match scores of documents. If no $orderby is
                          specified, the default sort order is descending by document match score.
                          There can be at most 32 $orderby clauses.
                        "queryLanguage": "str",  # Optional. A value that specifies the
                          language of the search query. Known values are: "none", "en-us", "en-gb",
                          "en-in", "en-ca", "en-au", "fr-fr", "fr-ca", "de-de", "es-es", "es-mx",
                          "zh-cn", "zh-tw", "pt-br", "pt-pt", "it-it", "ja-jp", "ko-kr", "ru-ru",
                          "cs-cz", "nl-be", "nl-nl", "hu-hu", "pl-pl", "sv-se", "tr-tr", "hi-in",
                          "ar-sa", "ar-eg", "ar-ma", "ar-kw", "ar-jo", "da-dk", "no-no", "bg-bg",
                          "hr-hr", "hr-ba", "ms-my", "ms-bn", "sl-sl", "ta-in", "vi-vn", "el-gr",
                          "ro-ro", "is-is", "id-id", "th-th", "lt-lt", "uk-ua", "lv-lv", "et-ee",
                          "ca-es", "fi-fi", "sr-ba", "sr-me", "sr-rs", "sk-sk", "nb-no", "hy-am",
                          "bn-in", "eu-es", "gl-es", "gu-in", "he-il", "ga-ie", "kn-in", "ml-in",
                          "mr-in", "fa-ae", "pa-in", "te-in", and "ur-pk".
                        "queryType": "str",  # Optional. A value that specifies the syntax of
                          the search query. The default is 'simple'. Use 'full' if your query uses the
                          Lucene query syntax. Known values are: "simple", "full", and "semantic".
                        "scoringParameters": [
                            "str"  # Optional. The list of parameter values to be used in
                              scoring functions (for example, referencePointParameter) using the format
                              name-values. For example, if the scoring profile defines a function with
                              a parameter called 'mylocation' the parameter string would be
                              "mylocation--122.2,44.8" (without the quotes).
                        ],
                        "scoringProfile": "str",  # Optional. The name of a scoring profile
                          to evaluate match scores for matching documents in order to sort the results.
                        "scoringStatistics": "str",  # Optional. A value that specifies
                          whether we want to calculate scoring statistics (such as document frequency)
                          globally for more consistent scoring, or locally, for lower latency. The
                          default is 'local'. Use 'global' to aggregate scoring statistics globally
                          before scoring. Using global scoring statistics can increase latency of
                          search queries. Known values are: "local" and "global".
                        "search": "str",  # Optional. A full-text search query expression;
                          Use "*" or omit this parameter to match all documents.
                        "searchFields": "str",  # Optional. The comma-separated list of field
                          names to which to scope the full-text search. When using fielded search
                          (fieldName:searchExpression) in a full Lucene query, the field names of each
                          fielded search expression take precedence over any field names listed in this
                          parameter.
                        "searchMode": "str",  # Optional. A value that specifies whether any
                          or all of the search terms must be matched in order to count the document as
                          a match. Known values are: "any" and "all".
                        "select": "str",  # Optional. The comma-separated list of fields to
                          retrieve. If unspecified, all fields marked as retrievable in the schema are
                          included.
                        "semanticConfiguration": "str",  # Optional. The name of a semantic
                          configuration that will be used when processing documents for queries of type
                          semantic.
                        "semanticFields": "str",  # Optional. The comma-separated list of
                          field names used for semantic search.
                        "sessionId": "str",  # Optional. A value to be used to create a
                          sticky session, which can help getting more consistent results. As long as
                          the same sessionId is used, a best-effort attempt will be made to target the
                          same replica set. Be wary that reusing the same sessionID values repeatedly
                          can interfere with the load balancing of the requests across replicas and
                          adversely affect the performance of the search service. The value used as
                          sessionId cannot start with a '_' character.
                        "skip": 0,  # Optional. The number of search results to skip. This
                          value cannot be greater than 100,000. If you need to scan documents in
                          sequence, but cannot use skip due to this limitation, consider using orderby
                          on a totally-ordered key and filter with a range query instead.
                        "speller": "str",  # Optional. A value that specified the type of the
                          speller to use to spell-correct individual search query terms. Known values
                          are: "none" and "lexicon".
                        "top": 0  # Optional. The number of search results to retrieve. This
                          can be used in conjunction with $skip to implement client-side paging of
                          search results. If results are truncated due to server-side paging, the
                          response will include a continuation token that can be used to issue another
                          Search request for the next page of results.
                    }
                }
        """

    @overload
    def search_post(
        self,
        search_request: IO,
        *,
        x_ms_client_request_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Searches for documents in the index.

        :param search_request: The definition of the Search request. Required.
        :type search_request: IO
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "@search.score": 0.0,  # The relevance score of the document
                              compared to other documents returned by the query. Required.
                            "@search.captions": [
                                {
                                    "highlights": "str",  # Optional. Same text
                                      passage as in the Text property with highlighted phrases most
                                      relevant to the query.
                                    "text": "str"  # Optional. A representative
                                      text passage extracted from the document most relevant to the
                                      search query.
                                }
                            ],
                            "@search.highlights": {
                                "str": [
                                    "str"  # Optional. Text fragments from the
                                      document that indicate the matching search terms, organized by
                                      each applicable field; null if hit highlighting was not enabled
                                      for the query.
                                ]
                            },
                            "@search.rerankerScore": 0.0  # Optional. The relevance score
                              computed by the semantic ranker for the top search results. Search
                              results are sorted by the RerankerScore first and then by the Score.
                              RerankerScore is only returned for queries of type 'semantic'.
                        }
                    ],
                    "@odata.count": 0,  # Optional. The total count of results found by the
                      search operation, or null if the count was not requested. If present, the count
                      may be greater than the number of results in this response. This can happen if
                      you use the $top or $skip parameters, or if Azure Cognitive Search can't return
                      all the requested documents in a single Search response.
                    "@odata.nextLink": "str",  # Optional. Continuation URL returned when Azure
                      Cognitive Search can't return all the requested results in a single Search
                      response. You can use this URL to formulate another GET or POST Search request to
                      get the next part of the search response. Make sure to use the same verb (GET or
                      POST) as the request that produced this response.
                    "@search.answers": [
                        {
                            "highlights": "str",  # Optional. Same text passage as in the
                              Text property with highlighted text phrases most relevant to the query.
                            "key": "str",  # Optional. The key of the document the answer
                              was extracted from.
                            "score": 0.0,  # Optional. The score value represents how
                              relevant the answer is to the query relative to other answers returned
                              for the query.
                            "text": "str"  # Optional. The text passage extracted from
                              the document contents as the answer.
                        }
                    ],
                    "@search.coverage": 0.0,  # Optional. A value indicating the percentage of
                      the index that was included in the query, or null if minimumCoverage was not
                      specified in the request.
                    "@search.facets": {
                        "str": [
                            {
                                "count": 0  # Optional. The approximate count of
                                  documents falling within the bucket described by this facet.
                            }
                        ]
                    },
                    "@search.nextPageParameters": {
                        "answers": "str",  # Optional. A value that specifies whether answers
                          should be returned as part of the search response. Known values are: "none"
                          and "extractive".
                        "captions": "str",  # Optional. A value that specifies whether
                          captions should be returned as part of the search response. Known values are:
                          "none" and "extractive".
                        "count": bool,  # Optional. A value that specifies whether to fetch
                          the total count of results. Default is false. Setting this value to true may
                          have a performance impact. Note that the count returned is an approximation.
                        "facets": [
                            "str"  # Optional. The list of facet expressions to apply to
                              the search query. Each facet expression contains a field name, optionally
                              followed by a comma-separated list of name:value pairs.
                        ],
                        "filter": "str",  # Optional. The OData $filter expression to apply
                          to the search query.
                        "highlight": "str",  # Optional. The comma-separated list of field
                          names to use for hit highlights. Only searchable fields can be used for hit
                          highlighting.
                        "highlightPostTag": "str",  # Optional. A string tag that is appended
                          to hit highlights. Must be set with highlightPreTag. Default is &lt;/em&gt;.
                        "highlightPreTag": "str",  # Optional. A string tag that is prepended
                          to hit highlights. Must be set with highlightPostTag. Default is &lt;em&gt;.
                        "minimumCoverage": 0.0,  # Optional. A number between 0 and 100
                          indicating the percentage of the index that must be covered by a search query
                          in order for the query to be reported as a success. This parameter can be
                          useful for ensuring search availability even for services with only one
                          replica. The default is 100.
                        "orderby": "str",  # Optional. The comma-separated list of OData
                          $orderby expressions by which to sort the results. Each expression can be
                          either a field name or a call to either the geo.distance() or the
                          search.score() functions. Each expression can be followed by asc to indicate
                          ascending, or desc to indicate descending. The default is ascending order.
                          Ties will be broken by the match scores of documents. If no $orderby is
                          specified, the default sort order is descending by document match score.
                          There can be at most 32 $orderby clauses.
                        "queryLanguage": "str",  # Optional. A value that specifies the
                          language of the search query. Known values are: "none", "en-us", "en-gb",
                          "en-in", "en-ca", "en-au", "fr-fr", "fr-ca", "de-de", "es-es", "es-mx",
                          "zh-cn", "zh-tw", "pt-br", "pt-pt", "it-it", "ja-jp", "ko-kr", "ru-ru",
                          "cs-cz", "nl-be", "nl-nl", "hu-hu", "pl-pl", "sv-se", "tr-tr", "hi-in",
                          "ar-sa", "ar-eg", "ar-ma", "ar-kw", "ar-jo", "da-dk", "no-no", "bg-bg",
                          "hr-hr", "hr-ba", "ms-my", "ms-bn", "sl-sl", "ta-in", "vi-vn", "el-gr",
                          "ro-ro", "is-is", "id-id", "th-th", "lt-lt", "uk-ua", "lv-lv", "et-ee",
                          "ca-es", "fi-fi", "sr-ba", "sr-me", "sr-rs", "sk-sk", "nb-no", "hy-am",
                          "bn-in", "eu-es", "gl-es", "gu-in", "he-il", "ga-ie", "kn-in", "ml-in",
                          "mr-in", "fa-ae", "pa-in", "te-in", and "ur-pk".
                        "queryType": "str",  # Optional. A value that specifies the syntax of
                          the search query. The default is 'simple'. Use 'full' if your query uses the
                          Lucene query syntax. Known values are: "simple", "full", and "semantic".
                        "scoringParameters": [
                            "str"  # Optional. The list of parameter values to be used in
                              scoring functions (for example, referencePointParameter) using the format
                              name-values. For example, if the scoring profile defines a function with
                              a parameter called 'mylocation' the parameter string would be
                              "mylocation--122.2,44.8" (without the quotes).
                        ],
                        "scoringProfile": "str",  # Optional. The name of a scoring profile
                          to evaluate match scores for matching documents in order to sort the results.
                        "scoringStatistics": "str",  # Optional. A value that specifies
                          whether we want to calculate scoring statistics (such as document frequency)
                          globally for more consistent scoring, or locally, for lower latency. The
                          default is 'local'. Use 'global' to aggregate scoring statistics globally
                          before scoring. Using global scoring statistics can increase latency of
                          search queries. Known values are: "local" and "global".
                        "search": "str",  # Optional. A full-text search query expression;
                          Use "*" or omit this parameter to match all documents.
                        "searchFields": "str",  # Optional. The comma-separated list of field
                          names to which to scope the full-text search. When using fielded search
                          (fieldName:searchExpression) in a full Lucene query, the field names of each
                          fielded search expression take precedence over any field names listed in this
                          parameter.
                        "searchMode": "str",  # Optional. A value that specifies whether any
                          or all of the search terms must be matched in order to count the document as
                          a match. Known values are: "any" and "all".
                        "select": "str",  # Optional. The comma-separated list of fields to
                          retrieve. If unspecified, all fields marked as retrievable in the schema are
                          included.
                        "semanticConfiguration": "str",  # Optional. The name of a semantic
                          configuration that will be used when processing documents for queries of type
                          semantic.
                        "semanticFields": "str",  # Optional. The comma-separated list of
                          field names used for semantic search.
                        "sessionId": "str",  # Optional. A value to be used to create a
                          sticky session, which can help getting more consistent results. As long as
                          the same sessionId is used, a best-effort attempt will be made to target the
                          same replica set. Be wary that reusing the same sessionID values repeatedly
                          can interfere with the load balancing of the requests across replicas and
                          adversely affect the performance of the search service. The value used as
                          sessionId cannot start with a '_' character.
                        "skip": 0,  # Optional. The number of search results to skip. This
                          value cannot be greater than 100,000. If you need to scan documents in
                          sequence, but cannot use skip due to this limitation, consider using orderby
                          on a totally-ordered key and filter with a range query instead.
                        "speller": "str",  # Optional. A value that specified the type of the
                          speller to use to spell-correct individual search query terms. Known values
                          are: "none" and "lexicon".
                        "top": 0  # Optional. The number of search results to retrieve. This
                          can be used in conjunction with $skip to implement client-side paging of
                          search results. If results are truncated due to server-side paging, the
                          response will include a continuation token that can be used to issue another
                          Search request for the next page of results.
                    }
                }
        """

    @distributed_trace
    def search_post(
        self, search_request: Union[JSON, IO], *, x_ms_client_request_id: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Searches for documents in the index.

        :param search_request: The definition of the Search request. Is either a model type or a IO
         type. Required.
        :type search_request: JSON or IO
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "@search.score": 0.0,  # The relevance score of the document
                              compared to other documents returned by the query. Required.
                            "@search.captions": [
                                {
                                    "highlights": "str",  # Optional. Same text
                                      passage as in the Text property with highlighted phrases most
                                      relevant to the query.
                                    "text": "str"  # Optional. A representative
                                      text passage extracted from the document most relevant to the
                                      search query.
                                }
                            ],
                            "@search.highlights": {
                                "str": [
                                    "str"  # Optional. Text fragments from the
                                      document that indicate the matching search terms, organized by
                                      each applicable field; null if hit highlighting was not enabled
                                      for the query.
                                ]
                            },
                            "@search.rerankerScore": 0.0  # Optional. The relevance score
                              computed by the semantic ranker for the top search results. Search
                              results are sorted by the RerankerScore first and then by the Score.
                              RerankerScore is only returned for queries of type 'semantic'.
                        }
                    ],
                    "@odata.count": 0,  # Optional. The total count of results found by the
                      search operation, or null if the count was not requested. If present, the count
                      may be greater than the number of results in this response. This can happen if
                      you use the $top or $skip parameters, or if Azure Cognitive Search can't return
                      all the requested documents in a single Search response.
                    "@odata.nextLink": "str",  # Optional. Continuation URL returned when Azure
                      Cognitive Search can't return all the requested results in a single Search
                      response. You can use this URL to formulate another GET or POST Search request to
                      get the next part of the search response. Make sure to use the same verb (GET or
                      POST) as the request that produced this response.
                    "@search.answers": [
                        {
                            "highlights": "str",  # Optional. Same text passage as in the
                              Text property with highlighted text phrases most relevant to the query.
                            "key": "str",  # Optional. The key of the document the answer
                              was extracted from.
                            "score": 0.0,  # Optional. The score value represents how
                              relevant the answer is to the query relative to other answers returned
                              for the query.
                            "text": "str"  # Optional. The text passage extracted from
                              the document contents as the answer.
                        }
                    ],
                    "@search.coverage": 0.0,  # Optional. A value indicating the percentage of
                      the index that was included in the query, or null if minimumCoverage was not
                      specified in the request.
                    "@search.facets": {
                        "str": [
                            {
                                "count": 0  # Optional. The approximate count of
                                  documents falling within the bucket described by this facet.
                            }
                        ]
                    },
                    "@search.nextPageParameters": {
                        "answers": "str",  # Optional. A value that specifies whether answers
                          should be returned as part of the search response. Known values are: "none"
                          and "extractive".
                        "captions": "str",  # Optional. A value that specifies whether
                          captions should be returned as part of the search response. Known values are:
                          "none" and "extractive".
                        "count": bool,  # Optional. A value that specifies whether to fetch
                          the total count of results. Default is false. Setting this value to true may
                          have a performance impact. Note that the count returned is an approximation.
                        "facets": [
                            "str"  # Optional. The list of facet expressions to apply to
                              the search query. Each facet expression contains a field name, optionally
                              followed by a comma-separated list of name:value pairs.
                        ],
                        "filter": "str",  # Optional. The OData $filter expression to apply
                          to the search query.
                        "highlight": "str",  # Optional. The comma-separated list of field
                          names to use for hit highlights. Only searchable fields can be used for hit
                          highlighting.
                        "highlightPostTag": "str",  # Optional. A string tag that is appended
                          to hit highlights. Must be set with highlightPreTag. Default is &lt;/em&gt;.
                        "highlightPreTag": "str",  # Optional. A string tag that is prepended
                          to hit highlights. Must be set with highlightPostTag. Default is &lt;em&gt;.
                        "minimumCoverage": 0.0,  # Optional. A number between 0 and 100
                          indicating the percentage of the index that must be covered by a search query
                          in order for the query to be reported as a success. This parameter can be
                          useful for ensuring search availability even for services with only one
                          replica. The default is 100.
                        "orderby": "str",  # Optional. The comma-separated list of OData
                          $orderby expressions by which to sort the results. Each expression can be
                          either a field name or a call to either the geo.distance() or the
                          search.score() functions. Each expression can be followed by asc to indicate
                          ascending, or desc to indicate descending. The default is ascending order.
                          Ties will be broken by the match scores of documents. If no $orderby is
                          specified, the default sort order is descending by document match score.
                          There can be at most 32 $orderby clauses.
                        "queryLanguage": "str",  # Optional. A value that specifies the
                          language of the search query. Known values are: "none", "en-us", "en-gb",
                          "en-in", "en-ca", "en-au", "fr-fr", "fr-ca", "de-de", "es-es", "es-mx",
                          "zh-cn", "zh-tw", "pt-br", "pt-pt", "it-it", "ja-jp", "ko-kr", "ru-ru",
                          "cs-cz", "nl-be", "nl-nl", "hu-hu", "pl-pl", "sv-se", "tr-tr", "hi-in",
                          "ar-sa", "ar-eg", "ar-ma", "ar-kw", "ar-jo", "da-dk", "no-no", "bg-bg",
                          "hr-hr", "hr-ba", "ms-my", "ms-bn", "sl-sl", "ta-in", "vi-vn", "el-gr",
                          "ro-ro", "is-is", "id-id", "th-th", "lt-lt", "uk-ua", "lv-lv", "et-ee",
                          "ca-es", "fi-fi", "sr-ba", "sr-me", "sr-rs", "sk-sk", "nb-no", "hy-am",
                          "bn-in", "eu-es", "gl-es", "gu-in", "he-il", "ga-ie", "kn-in", "ml-in",
                          "mr-in", "fa-ae", "pa-in", "te-in", and "ur-pk".
                        "queryType": "str",  # Optional. A value that specifies the syntax of
                          the search query. The default is 'simple'. Use 'full' if your query uses the
                          Lucene query syntax. Known values are: "simple", "full", and "semantic".
                        "scoringParameters": [
                            "str"  # Optional. The list of parameter values to be used in
                              scoring functions (for example, referencePointParameter) using the format
                              name-values. For example, if the scoring profile defines a function with
                              a parameter called 'mylocation' the parameter string would be
                              "mylocation--122.2,44.8" (without the quotes).
                        ],
                        "scoringProfile": "str",  # Optional. The name of a scoring profile
                          to evaluate match scores for matching documents in order to sort the results.
                        "scoringStatistics": "str",  # Optional. A value that specifies
                          whether we want to calculate scoring statistics (such as document frequency)
                          globally for more consistent scoring, or locally, for lower latency. The
                          default is 'local'. Use 'global' to aggregate scoring statistics globally
                          before scoring. Using global scoring statistics can increase latency of
                          search queries. Known values are: "local" and "global".
                        "search": "str",  # Optional. A full-text search query expression;
                          Use "*" or omit this parameter to match all documents.
                        "searchFields": "str",  # Optional. The comma-separated list of field
                          names to which to scope the full-text search. When using fielded search
                          (fieldName:searchExpression) in a full Lucene query, the field names of each
                          fielded search expression take precedence over any field names listed in this
                          parameter.
                        "searchMode": "str",  # Optional. A value that specifies whether any
                          or all of the search terms must be matched in order to count the document as
                          a match. Known values are: "any" and "all".
                        "select": "str",  # Optional. The comma-separated list of fields to
                          retrieve. If unspecified, all fields marked as retrievable in the schema are
                          included.
                        "semanticConfiguration": "str",  # Optional. The name of a semantic
                          configuration that will be used when processing documents for queries of type
                          semantic.
                        "semanticFields": "str",  # Optional. The comma-separated list of
                          field names used for semantic search.
                        "sessionId": "str",  # Optional. A value to be used to create a
                          sticky session, which can help getting more consistent results. As long as
                          the same sessionId is used, a best-effort attempt will be made to target the
                          same replica set. Be wary that reusing the same sessionID values repeatedly
                          can interfere with the load balancing of the requests across replicas and
                          adversely affect the performance of the search service. The value used as
                          sessionId cannot start with a '_' character.
                        "skip": 0,  # Optional. The number of search results to skip. This
                          value cannot be greater than 100,000. If you need to scan documents in
                          sequence, but cannot use skip due to this limitation, consider using orderby
                          on a totally-ordered key and filter with a range query instead.
                        "speller": "str",  # Optional. A value that specified the type of the
                          speller to use to spell-correct individual search query terms. Known values
                          are: "none" and "lexicon".
                        "top": 0  # Optional. The number of search results to retrieve. This
                          can be used in conjunction with $skip to implement client-side paging of
                          search results. If results are truncated due to server-side paging, the
                          response will include a continuation token that can be used to issue another
                          Search request for the next page of results.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(search_request, (IO, bytes)):
            _content = search_request
        else:
            _json = search_request

        request = build_documents_search_post_request(
            x_ms_client_request_id=x_ms_client_request_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "indexName": self._serialize.url("self._config.index_name", self._config.index_name, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get(
        self,
        key: str,
        *,
        selected_fields: Optional[List[str]] = None,
        x_ms_client_request_id: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieves a document from the index.

        :param key: The key of the document to retrieve. Required.
        :type key: str
        :keyword selected_fields: List of field names to retrieve for the document; Any field not
         retrieved will be missing from the returned document. Default value is None.
        :paramtype selected_fields: list[str]
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :return: JSON
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_documents_get_request(
            key=key,
            selected_fields=selected_fields,
            x_ms_client_request_id=x_ms_client_request_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "indexName": self._serialize.url("self._config.index_name", self._config.index_name, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def suggest_get(
        self,
        *,
        search_text: str,
        suggester_name: str,
        filter: Optional[str] = None,
        use_fuzzy_matching: Optional[bool] = None,
        highlight_post_tag: Optional[str] = None,
        highlight_pre_tag: Optional[str] = None,
        minimum_coverage: Optional[float] = None,
        order_by: Optional[List[str]] = None,
        search_fields: Optional[List[str]] = None,
        select: Optional[List[str]] = None,
        top: Optional[int] = None,
        x_ms_client_request_id: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """Suggests documents in the index that match the given partial query text.

        :keyword search_text: The search text to use to suggest documents. Must be at least 1
         character, and no more than 100 characters. Required.
        :paramtype search_text: str
        :keyword suggester_name: The name of the suggester as specified in the suggesters collection
         that's part of the index definition. Required.
        :paramtype suggester_name: str
        :keyword filter: An OData expression that filters the documents considered for suggestions.
         Default value is None.
        :paramtype filter: str
        :keyword use_fuzzy_matching: A value indicating whether to use fuzzy matching for the
         suggestions query. Default is false. When set to true, the query will find terms even if
         there's a substituted or missing character in the search text. While this provides a better
         experience in some scenarios, it comes at a performance cost as fuzzy suggestions queries are
         slower and consume more resources. Default value is None.
        :paramtype use_fuzzy_matching: bool
        :keyword highlight_post_tag: A string tag that is appended to hit highlights. Must be set with
         highlightPreTag. If omitted, hit highlighting of suggestions is disabled. Default value is
         None.
        :paramtype highlight_post_tag: str
        :keyword highlight_pre_tag: A string tag that is prepended to hit highlights. Must be set with
         highlightPostTag. If omitted, hit highlighting of suggestions is disabled. Default value is
         None.
        :paramtype highlight_pre_tag: str
        :keyword minimum_coverage: A number between 0 and 100 indicating the percentage of the index
         that must be covered by a suggestions query in order for the query to be reported as a success.
         This parameter can be useful for ensuring search availability even for services with only one
         replica. The default is 80. Default value is None.
        :paramtype minimum_coverage: float
        :keyword order_by: The list of OData $orderby expressions by which to sort the results. Each
         expression can be either a field name or a call to either the geo.distance() or the
         search.score() functions. Each expression can be followed by asc to indicate ascending, or desc
         to indicate descending. The default is ascending order. Ties will be broken by the match scores
         of documents. If no $orderby is specified, the default sort order is descending by document
         match score. There can be at most 32 $orderby clauses. Default value is None.
        :paramtype order_by: list[str]
        :keyword search_fields: The list of field names to search for the specified search text. Target
         fields must be included in the specified suggester. Default value is None.
        :paramtype search_fields: list[str]
        :keyword select: The list of fields to retrieve. If unspecified, only the key field will be
         included in the results. Default value is None.
        :paramtype select: list[str]
        :keyword top: The number of suggestions to retrieve. The value must be a number between 1 and
         100. The default is 5. Default value is None.
        :paramtype top: int
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "@search.text": "str"  # The text of the suggestion result.
                              Required.
                        }
                    ],
                    "@search.coverage": 0.0  # Optional. A value indicating the percentage of the
                      index that was included in the query, or null if minimumCoverage was not set in
                      the request.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_documents_suggest_get_request(
            search_text=search_text,
            suggester_name=suggester_name,
            filter=filter,
            use_fuzzy_matching=use_fuzzy_matching,
            highlight_post_tag=highlight_post_tag,
            highlight_pre_tag=highlight_pre_tag,
            minimum_coverage=minimum_coverage,
            order_by=order_by,
            search_fields=search_fields,
            select=select,
            top=top,
            x_ms_client_request_id=x_ms_client_request_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "indexName": self._serialize.url("self._config.index_name", self._config.index_name, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def suggest_post(
        self,
        suggest_request: JSON,
        *,
        x_ms_client_request_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Suggests documents in the index that match the given partial query text.

        :param suggest_request: The Suggest request. Required.
        :type suggest_request: JSON
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                suggest_request = {
                    "search": "str",  # The search text to use to suggest documents. Must be at
                      least 1 character, and no more than 100 characters. Required.
                    "suggesterName": "str",  # The name of the suggester as specified in the
                      suggesters collection that's part of the index definition. Required.
                    "filter": "str",  # Optional. An OData expression that filters the documents
                      considered for suggestions.
                    "fuzzy": bool,  # Optional. A value indicating whether to use fuzzy matching
                      for the suggestion query. Default is false. When set to true, the query will find
                      suggestions even if there's a substituted or missing character in the search
                      text. While this provides a better experience in some scenarios, it comes at a
                      performance cost as fuzzy suggestion searches are slower and consume more
                      resources.
                    "highlightPostTag": "str",  # Optional. A string tag that is appended to hit
                      highlights. Must be set with highlightPreTag. If omitted, hit highlighting of
                      suggestions is disabled.
                    "highlightPreTag": "str",  # Optional. A string tag that is prepended to hit
                      highlights. Must be set with highlightPostTag. If omitted, hit highlighting of
                      suggestions is disabled.
                    "minimumCoverage": 0.0,  # Optional. A number between 0 and 100 indicating
                      the percentage of the index that must be covered by a suggestion query in order
                      for the query to be reported as a success. This parameter can be useful for
                      ensuring search availability even for services with only one replica. The default
                      is 80.
                    "orderby": "str",  # Optional. The comma-separated list of OData $orderby
                      expressions by which to sort the results. Each expression can be either a field
                      name or a call to either the geo.distance() or the search.score() functions. Each
                      expression can be followed by asc to indicate ascending, or desc to indicate
                      descending. The default is ascending order. Ties will be broken by the match
                      scores of documents. If no $orderby is specified, the default sort order is
                      descending by document match score. There can be at most 32 $orderby clauses.
                    "searchFields": "str",  # Optional. The comma-separated list of field names
                      to search for the specified search text. Target fields must be included in the
                      specified suggester.
                    "select": "str",  # Optional. The comma-separated list of fields to retrieve.
                      If unspecified, only the key field will be included in the results.
                    "top": 0  # Optional. The number of suggestions to retrieve. This must be a
                      value between 1 and 100. The default is 5.
                }

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "@search.text": "str"  # The text of the suggestion result.
                              Required.
                        }
                    ],
                    "@search.coverage": 0.0  # Optional. A value indicating the percentage of the
                      index that was included in the query, or null if minimumCoverage was not set in
                      the request.
                }
        """

    @overload
    def suggest_post(
        self,
        suggest_request: IO,
        *,
        x_ms_client_request_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Suggests documents in the index that match the given partial query text.

        :param suggest_request: The Suggest request. Required.
        :type suggest_request: IO
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "@search.text": "str"  # The text of the suggestion result.
                              Required.
                        }
                    ],
                    "@search.coverage": 0.0  # Optional. A value indicating the percentage of the
                      index that was included in the query, or null if minimumCoverage was not set in
                      the request.
                }
        """

    @distributed_trace
    def suggest_post(
        self, suggest_request: Union[JSON, IO], *, x_ms_client_request_id: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Suggests documents in the index that match the given partial query text.

        :param suggest_request: The Suggest request. Is either a model type or a IO type. Required.
        :type suggest_request: JSON or IO
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "@search.text": "str"  # The text of the suggestion result.
                              Required.
                        }
                    ],
                    "@search.coverage": 0.0  # Optional. A value indicating the percentage of the
                      index that was included in the query, or null if minimumCoverage was not set in
                      the request.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(suggest_request, (IO, bytes)):
            _content = suggest_request
        else:
            _json = suggest_request

        request = build_documents_suggest_post_request(
            x_ms_client_request_id=x_ms_client_request_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "indexName": self._serialize.url("self._config.index_name", self._config.index_name, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def index(
        self,
        batch: JSON,
        *,
        x_ms_client_request_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Sends a batch of document write actions to the index.

        :param batch: The batch of index actions. Required.
        :type batch: JSON
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                batch = {
                    "value": [
                        {
                            "@search.action": "str"  # Optional. The operation to perform
                              on a document in an indexing batch. Known values are: "upload", "merge",
                              "mergeOrUpload", and "delete".
                        }
                    ]
                }

                # response body for status code(s): 200, 207
                response == {
                    "value": [
                        {
                            "key": "str",  # The key of a document that was in the
                              indexing request. Required.
                            "status": bool,  # A value indicating whether the indexing
                              operation succeeded for the document identified by the key. Required.
                            "statusCode": 0,  # The status code of the indexing
                              operation. Possible values include: 200 for a successful update or
                              delete, 201 for successful document creation, 400 for a malformed input
                              document, 404 for document not found, 409 for a version conflict, 422
                              when the index is temporarily unavailable, or 503 for when the service is
                              too busy. Required.
                            "errorMessage": "str"  # Optional. The error message
                              explaining why the indexing operation failed for the document identified
                              by the key; null if indexing succeeded.
                        }
                    ]
                }
        """

    @overload
    def index(
        self,
        batch: IO,
        *,
        x_ms_client_request_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Sends a batch of document write actions to the index.

        :param batch: The batch of index actions. Required.
        :type batch: IO
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 207
                response == {
                    "value": [
                        {
                            "key": "str",  # The key of a document that was in the
                              indexing request. Required.
                            "status": bool,  # A value indicating whether the indexing
                              operation succeeded for the document identified by the key. Required.
                            "statusCode": 0,  # The status code of the indexing
                              operation. Possible values include: 200 for a successful update or
                              delete, 201 for successful document creation, 400 for a malformed input
                              document, 404 for document not found, 409 for a version conflict, 422
                              when the index is temporarily unavailable, or 503 for when the service is
                              too busy. Required.
                            "errorMessage": "str"  # Optional. The error message
                              explaining why the indexing operation failed for the document identified
                              by the key; null if indexing succeeded.
                        }
                    ]
                }
        """

    @distributed_trace
    def index(self, batch: Union[JSON, IO], *, x_ms_client_request_id: Optional[str] = None, **kwargs: Any) -> JSON:
        """Sends a batch of document write actions to the index.

        :param batch: The batch of index actions. Is either a model type or a IO type. Required.
        :type batch: JSON or IO
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 207
                response == {
                    "value": [
                        {
                            "key": "str",  # The key of a document that was in the
                              indexing request. Required.
                            "status": bool,  # A value indicating whether the indexing
                              operation succeeded for the document identified by the key. Required.
                            "statusCode": 0,  # The status code of the indexing
                              operation. Possible values include: 200 for a successful update or
                              delete, 201 for successful document creation, 400 for a malformed input
                              document, 404 for document not found, 409 for a version conflict, 422
                              when the index is temporarily unavailable, or 503 for when the service is
                              too busy. Required.
                            "errorMessage": "str"  # Optional. The error message
                              explaining why the indexing operation failed for the document identified
                              by the key; null if indexing succeeded.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(batch, (IO, bytes)):
            _content = batch
        else:
            _json = batch

        request = build_documents_index_request(
            x_ms_client_request_id=x_ms_client_request_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "indexName": self._serialize.url("self._config.index_name", self._config.index_name, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 207]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 207:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def autocomplete_get(
        self,
        *,
        search_text: str,
        suggester_name: str,
        x_ms_client_request_id: Optional[str] = None,
        autocomplete_mode: Optional[str] = None,
        filter: Optional[str] = None,
        use_fuzzy_matching: Optional[bool] = None,
        highlight_post_tag: Optional[str] = None,
        highlight_pre_tag: Optional[str] = None,
        minimum_coverage: Optional[float] = None,
        search_fields: Optional[List[str]] = None,
        top: Optional[int] = None,
        **kwargs: Any
    ) -> JSON:
        """Autocompletes incomplete query terms based on input text and matching terms in the index.

        :keyword search_text: The incomplete term which should be auto-completed. Required.
        :paramtype search_text: str
        :keyword suggester_name: The name of the suggester as specified in the suggesters collection
         that's part of the index definition. Required.
        :paramtype suggester_name: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword autocomplete_mode: Specifies the mode for Autocomplete. The default is 'oneTerm'. Use
         'twoTerms' to get shingles and 'oneTermWithContext' to use the current context while producing
         auto-completed terms. Known values are: "oneTerm", "twoTerms", and "oneTermWithContext".
         Default value is None.
        :paramtype autocomplete_mode: str
        :keyword filter: An OData expression that filters the documents used to produce completed terms
         for the Autocomplete result. Default value is None.
        :paramtype filter: str
        :keyword use_fuzzy_matching: A value indicating whether to use fuzzy matching for the
         autocomplete query. Default is false. When set to true, the query will find terms even if
         there's a substituted or missing character in the search text. While this provides a better
         experience in some scenarios, it comes at a performance cost as fuzzy autocomplete queries are
         slower and consume more resources. Default value is None.
        :paramtype use_fuzzy_matching: bool
        :keyword highlight_post_tag: A string tag that is appended to hit highlights. Must be set with
         highlightPreTag. If omitted, hit highlighting is disabled. Default value is None.
        :paramtype highlight_post_tag: str
        :keyword highlight_pre_tag: A string tag that is prepended to hit highlights. Must be set with
         highlightPostTag. If omitted, hit highlighting is disabled. Default value is None.
        :paramtype highlight_pre_tag: str
        :keyword minimum_coverage: A number between 0 and 100 indicating the percentage of the index
         that must be covered by an autocomplete query in order for the query to be reported as a
         success. This parameter can be useful for ensuring search availability even for services with
         only one replica. The default is 80. Default value is None.
        :paramtype minimum_coverage: float
        :keyword search_fields: The list of field names to consider when querying for auto-completed
         terms. Target fields must be included in the specified suggester. Default value is None.
        :paramtype search_fields: list[str]
        :keyword top: The number of auto-completed terms to retrieve. This must be a value between 1
         and 100. The default is 5. Default value is None.
        :paramtype top: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "queryPlusText": "str",  # The query along with the completed
                              term. Required.
                            "text": "str"  # The completed term. Required.
                        }
                    ],
                    "@search.coverage": 0.0  # Optional. A value indicating the percentage of the
                      index that was considered by the autocomplete request, or null if minimumCoverage
                      was not specified in the request.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_documents_autocomplete_get_request(
            search_text=search_text,
            suggester_name=suggester_name,
            x_ms_client_request_id=x_ms_client_request_id,
            autocomplete_mode=autocomplete_mode,
            filter=filter,
            use_fuzzy_matching=use_fuzzy_matching,
            highlight_post_tag=highlight_post_tag,
            highlight_pre_tag=highlight_pre_tag,
            minimum_coverage=minimum_coverage,
            search_fields=search_fields,
            top=top,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "indexName": self._serialize.url("self._config.index_name", self._config.index_name, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def autocomplete_post(
        self,
        autocomplete_request: JSON,
        *,
        x_ms_client_request_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Autocompletes incomplete query terms based on input text and matching terms in the index.

        :param autocomplete_request: The definition of the Autocomplete request. Required.
        :type autocomplete_request: JSON
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                autocomplete_request = {
                    "search": "str",  # The search text on which to base autocomplete results.
                      Required.
                    "suggesterName": "str",  # The name of the suggester as specified in the
                      suggesters collection that's part of the index definition. Required.
                    "autocompleteMode": "str",  # Optional. Specifies the mode for Autocomplete.
                      The default is 'oneTerm'. Use 'twoTerms' to get shingles and 'oneTermWithContext'
                      to use the current context while producing auto-completed terms. Known values
                      are: "oneTerm", "twoTerms", and "oneTermWithContext".
                    "filter": "str",  # Optional. An OData expression that filters the documents
                      used to produce completed terms for the Autocomplete result.
                    "fuzzy": bool,  # Optional. A value indicating whether to use fuzzy matching
                      for the autocomplete query. Default is false. When set to true, the query will
                      autocomplete terms even if there's a substituted or missing character in the
                      search text. While this provides a better experience in some scenarios, it comes
                      at a performance cost as fuzzy autocomplete queries are slower and consume more
                      resources.
                    "highlightPostTag": "str",  # Optional. A string tag that is appended to hit
                      highlights. Must be set with highlightPreTag. If omitted, hit highlighting is
                      disabled.
                    "highlightPreTag": "str",  # Optional. A string tag that is prepended to hit
                      highlights. Must be set with highlightPostTag. If omitted, hit highlighting is
                      disabled.
                    "minimumCoverage": 0.0,  # Optional. A number between 0 and 100 indicating
                      the percentage of the index that must be covered by an autocomplete query in
                      order for the query to be reported as a success. This parameter can be useful for
                      ensuring search availability even for services with only one replica. The default
                      is 80.
                    "searchFields": "str",  # Optional. The comma-separated list of field names
                      to consider when querying for auto-completed terms. Target fields must be
                      included in the specified suggester.
                    "top": 0  # Optional. The number of auto-completed terms to retrieve. This
                      must be a value between 1 and 100. The default is 5.
                }

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "queryPlusText": "str",  # The query along with the completed
                              term. Required.
                            "text": "str"  # The completed term. Required.
                        }
                    ],
                    "@search.coverage": 0.0  # Optional. A value indicating the percentage of the
                      index that was considered by the autocomplete request, or null if minimumCoverage
                      was not specified in the request.
                }
        """

    @overload
    def autocomplete_post(
        self,
        autocomplete_request: IO,
        *,
        x_ms_client_request_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Autocompletes incomplete query terms based on input text and matching terms in the index.

        :param autocomplete_request: The definition of the Autocomplete request. Required.
        :type autocomplete_request: IO
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "queryPlusText": "str",  # The query along with the completed
                              term. Required.
                            "text": "str"  # The completed term. Required.
                        }
                    ],
                    "@search.coverage": 0.0  # Optional. A value indicating the percentage of the
                      index that was considered by the autocomplete request, or null if minimumCoverage
                      was not specified in the request.
                }
        """

    @distributed_trace
    def autocomplete_post(
        self, autocomplete_request: Union[JSON, IO], *, x_ms_client_request_id: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Autocompletes incomplete query terms based on input text and matching terms in the index.

        :param autocomplete_request: The definition of the Autocomplete request. Is either a model type
         or a IO type. Required.
        :type autocomplete_request: JSON or IO
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "queryPlusText": "str",  # The query along with the completed
                              term. Required.
                            "text": "str"  # The completed term. Required.
                        }
                    ],
                    "@search.coverage": 0.0  # Optional. A value indicating the percentage of the
                      index that was considered by the autocomplete request, or null if minimumCoverage
                      was not specified in the request.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(autocomplete_request, (IO, bytes)):
            _content = autocomplete_request
        else:
            _json = autocomplete_request

        request = build_documents_autocomplete_post_request(
            x_ms_client_request_id=x_ms_client_request_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "indexName": self._serialize.url("self._config.index_name", self._config.index_name, "str"),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)
