# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.2.1, generator: {generator})
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import sys
from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
import urllib.parse

from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict

from ...operations._operations import (
    build_aliases_create_or_update_request,
    build_aliases_create_request,
    build_aliases_delete_request,
    build_aliases_get_request,
    build_aliases_list_request,
    build_data_sources_create_or_update_request,
    build_data_sources_create_request,
    build_data_sources_delete_request,
    build_data_sources_get_request,
    build_data_sources_list_request,
    build_indexers_create_or_update_request,
    build_indexers_create_request,
    build_indexers_delete_request,
    build_indexers_get_request,
    build_indexers_get_status_request,
    build_indexers_list_request,
    build_indexers_reset_docs_request,
    build_indexers_reset_request,
    build_indexers_run_request,
    build_indexes_analyze_request,
    build_indexes_create_or_update_request,
    build_indexes_create_request,
    build_indexes_delete_request,
    build_indexes_get_request,
    build_indexes_get_statistics_request,
    build_indexes_list_request,
    build_search_service_get_service_statistics_request,
    build_skillsets_create_or_update_request,
    build_skillsets_create_request,
    build_skillsets_delete_request,
    build_skillsets_get_request,
    build_skillsets_list_request,
    build_skillsets_reset_skills_request,
    build_synonym_maps_create_or_update_request,
    build_synonym_maps_create_request,
    build_synonym_maps_delete_request,
    build_synonym_maps_get_request,
    build_synonym_maps_list_request,
)
from .._vendor import SearchServiceClientMixinABC

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]


class DataSourcesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~search_service_client.aio.SearchServiceClient`'s
        :attr:`data_sources` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def create_or_update(
        self,
        data_source_name: str,
        data_source: JSON,
        *,
        prefer: str,
        x_ms_client_request_id: Optional[str] = None,
        if_match: Optional[str] = None,
        if_none_match: Optional[str] = None,
        skip_indexer_reset_requirement_for_cache: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new datasource or updates a datasource if it already exists.

        :param data_source_name: The name of the datasource to create or update. Required.
        :type data_source_name: str
        :param data_source: The definition of the datasource to create or update. Required.
        :type data_source: JSON
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword if_match: Defines the If-Match condition. The operation will be performed only if the
         ETag on the server matches this value. Default value is None.
        :paramtype if_match: str
        :keyword if_none_match: Defines the If-None-Match condition. The operation will be performed
         only if the ETag on the server does not match this value. Default value is None.
        :paramtype if_none_match: str
        :keyword skip_indexer_reset_requirement_for_cache: Ignores cache reset requirements. Default
         value is None.
        :paramtype skip_indexer_reset_requirement_for_cache: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # JSON input template you can fill out and use as your body input.
                data_source = {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ':code:`<unchanged>`' if you do not want the connection
                          string updated.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "identity": search_indexer_data_identity
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # response body for status code(s): 200, 201
                response == {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ':code:`<unchanged>`' if you do not want the connection
                          string updated.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "identity": search_indexer_data_identity
                }
        """

    @overload
    async def create_or_update(
        self,
        data_source_name: str,
        data_source: IO,
        *,
        prefer: str,
        x_ms_client_request_id: Optional[str] = None,
        if_match: Optional[str] = None,
        if_none_match: Optional[str] = None,
        skip_indexer_reset_requirement_for_cache: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new datasource or updates a datasource if it already exists.

        :param data_source_name: The name of the datasource to create or update. Required.
        :type data_source_name: str
        :param data_source: The definition of the datasource to create or update. Required.
        :type data_source: IO
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword if_match: Defines the If-Match condition. The operation will be performed only if the
         ETag on the server matches this value. Default value is None.
        :paramtype if_match: str
        :keyword if_none_match: Defines the If-None-Match condition. The operation will be performed
         only if the ETag on the server does not match this value. Default value is None.
        :paramtype if_none_match: str
        :keyword skip_indexer_reset_requirement_for_cache: Ignores cache reset requirements. Default
         value is None.
        :paramtype skip_indexer_reset_requirement_for_cache: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # response body for status code(s): 200, 201
                response == {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ':code:`<unchanged>`' if you do not want the connection
                          string updated.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "identity": search_indexer_data_identity
                }
        """

    @distributed_trace_async
    async def create_or_update(
        self,
        data_source_name: str,
        data_source: Union[JSON, IO],
        *,
        prefer: str,
        x_ms_client_request_id: Optional[str] = None,
        if_match: Optional[str] = None,
        if_none_match: Optional[str] = None,
        skip_indexer_reset_requirement_for_cache: Optional[bool] = None,
        **kwargs: Any
    ) -> JSON:
        """Creates a new datasource or updates a datasource if it already exists.

        :param data_source_name: The name of the datasource to create or update. Required.
        :type data_source_name: str
        :param data_source: The definition of the datasource to create or update. Is either a model
         type or a IO type. Required.
        :type data_source: JSON or IO
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword if_match: Defines the If-Match condition. The operation will be performed only if the
         ETag on the server matches this value. Default value is None.
        :paramtype if_match: str
        :keyword if_none_match: Defines the If-None-Match condition. The operation will be performed
         only if the ETag on the server does not match this value. Default value is None.
        :paramtype if_none_match: str
        :keyword skip_indexer_reset_requirement_for_cache: Ignores cache reset requirements. Default
         value is None.
        :paramtype skip_indexer_reset_requirement_for_cache: bool
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # response body for status code(s): 200, 201
                response == {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ':code:`<unchanged>`' if you do not want the connection
                          string updated.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "identity": search_indexer_data_identity
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(data_source, (IO, bytes)):
            _content = data_source
        else:
            _json = data_source

        request = build_data_sources_create_or_update_request(
            data_source_name=data_source_name,
            prefer=prefer,
            x_ms_client_request_id=x_ms_client_request_id,
            if_match=if_match,
            if_none_match=if_none_match,
            skip_indexer_reset_requirement_for_cache=skip_indexer_reset_requirement_for_cache,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def delete(  # pylint: disable=inconsistent-return-statements
        self,
        data_source_name: str,
        *,
        x_ms_client_request_id: Optional[str] = None,
        if_match: Optional[str] = None,
        if_none_match: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """Deletes a datasource.

        :param data_source_name: The name of the datasource to delete. Required.
        :type data_source_name: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword if_match: Defines the If-Match condition. The operation will be performed only if the
         ETag on the server matches this value. Default value is None.
        :paramtype if_match: str
        :keyword if_none_match: Defines the If-None-Match condition. The operation will be performed
         only if the ETag on the server does not match this value. Default value is None.
        :paramtype if_none_match: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_data_sources_delete_request(
            data_source_name=data_source_name,
            x_ms_client_request_id=x_ms_client_request_id,
            if_match=if_match,
            if_none_match=if_none_match,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get(self, data_source_name: str, *, x_ms_client_request_id: Optional[str] = None, **kwargs: Any) -> JSON:
        """Retrieves a datasource definition.

        :param data_source_name: The name of the datasource to retrieve. Required.
        :type data_source_name: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # response body for status code(s): 200
                response == {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ':code:`<unchanged>`' if you do not want the connection
                          string updated.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "identity": search_indexer_data_identity
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_data_sources_get_request(
            data_source_name=data_source_name,
            x_ms_client_request_id=x_ms_client_request_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def list(
        self, *, select: Optional[str] = None, x_ms_client_request_id: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Lists all datasources available for a search service.

        :keyword select: Selects which top-level properties of the data sources to retrieve. Specified
         as a comma-separated list of JSON property names, or '*' for all properties. The default is all
         properties. Default value is None.
        :paramtype select: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "container": {
                                "name": "str",  # The name of the table or view (for
                                  Azure SQL data source) or collection (for CosmosDB data source) that
                                  will be indexed. Required.
                                "query": "str"  # Optional. A query that is applied
                                  to this data container. The syntax and meaning of this parameter is
                                  datasource-specific. Not supported by Azure SQL datasources.
                            },
                            "credentials": {
                                "connectionString": "str"  # Optional. The connection
                                  string for the datasource. Set to ':code:`<unchanged>`' if you do not
                                  want the connection string updated.
                            },
                            "name": "str",  # The name of the datasource. Required.
                            "type": "str",  # The type of the datasource. Required. Known
                              values are: "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql",
                              and "adlsgen2".
                            "@odata.etag": "str",  # Optional. The ETag of the data
                              source.
                            "dataChangeDetectionPolicy": data_change_detection_policy,
                            "dataDeletionDetectionPolicy":
                              data_deletion_detection_policy,
                            "description": "str",  # Optional. The description of the
                              datasource.
                            "encryptionKey": {
                                "keyVaultKeyName": "str",  # The name of your Azure
                                  Key Vault key to be used to encrypt your data at rest. Required.
                                "keyVaultKeyVersion": "str",  # The version of your
                                  Azure Key Vault key to be used to encrypt your data at rest.
                                  Required.
                                "keyVaultUri": "str",  # The URI of your Azure Key
                                  Vault, also referred to as DNS name, that contains the key to be used
                                  to encrypt your data at rest. An example URI might be
                                  https://my-keyvault-name.vault.azure.net. Required.
                                "accessCredentials": {
                                    "applicationId": "str",  # An AAD Application
                                      ID that was granted the required access permissions to the Azure
                                      Key Vault that is to be used when encrypting your data at rest.
                                      The Application ID should not be confused with the Object ID for
                                      your AAD Application. Required.
                                    "applicationSecret": "str"  # Optional. The
                                      authentication key of the specified AAD application.
                                },
                                "identity": search_indexer_data_identity
                            },
                            "identity": search_indexer_data_identity
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_data_sources_list_request(
            select=select,
            x_ms_client_request_id=x_ms_client_request_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def create(
        self,
        data_source: JSON,
        *,
        x_ms_client_request_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new datasource.

        :param data_source: The definition of the datasource to create. Required.
        :type data_source: JSON
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # JSON input template you can fill out and use as your body input.
                data_source = {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ':code:`<unchanged>`' if you do not want the connection
                          string updated.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "identity": search_indexer_data_identity
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # response body for status code(s): 201
                response == {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ':code:`<unchanged>`' if you do not want the connection
                          string updated.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "identity": search_indexer_data_identity
                }
        """

    @overload
    async def create(
        self,
        data_source: IO,
        *,
        x_ms_client_request_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new datasource.

        :param data_source: The definition of the datasource to create. Required.
        :type data_source: IO
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # response body for status code(s): 201
                response == {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ':code:`<unchanged>`' if you do not want the connection
                          string updated.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "identity": search_indexer_data_identity
                }
        """

    @distributed_trace_async
    async def create(
        self, data_source: Union[JSON, IO], *, x_ms_client_request_id: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Creates a new datasource.

        :param data_source: The definition of the datasource to create. Is either a model type or a IO
         type. Required.
        :type data_source: JSON or IO
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy":
                data_change_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
                    "highWaterMarkColumnName": "str"  # The name of the high water mark column.
                      Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy":
                data_change_detection_policy = {
                    "@odata.type": "  #Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy":
                data_deletion_detection_policy = {
                    "@odata.type": ",
                      #Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy"
                    "softDeleteColumnName": "str",  # Optional. The name of the column to use for
                      soft-deletion detection.
                    "softDeleteMarkerValue": "str"  # Optional. The marker value that identifies
                      an item as deleted.
                }

                # response body for status code(s): 201
                response == {
                    "container": {
                        "name": "str",  # The name of the table or view (for Azure SQL data
                          source) or collection (for CosmosDB data source) that will be indexed.
                          Required.
                        "query": "str"  # Optional. A query that is applied to this data
                          container. The syntax and meaning of this parameter is datasource-specific.
                          Not supported by Azure SQL datasources.
                    },
                    "credentials": {
                        "connectionString": "str"  # Optional. The connection string for the
                          datasource. Set to ':code:`<unchanged>`' if you do not want the connection
                          string updated.
                    },
                    "name": "str",  # The name of the datasource. Required.
                    "type": "str",  # The type of the datasource. Required. Known values are:
                      "azuresql", "cosmosdb", "azureblob", "azuretable", "mysql", and "adlsgen2".
                    "@odata.etag": "str",  # Optional. The ETag of the data source.
                    "dataChangeDetectionPolicy": data_change_detection_policy,
                    "dataDeletionDetectionPolicy": data_deletion_detection_policy,
                    "description": "str",  # Optional. The description of the datasource.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "identity": search_indexer_data_identity
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(data_source, (IO, bytes)):
            _content = data_source
        else:
            _json = data_source

        request = build_data_sources_create_request(
            x_ms_client_request_id=x_ms_client_request_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class IndexersOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~search_service_client.aio.SearchServiceClient`'s
        :attr:`indexers` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def reset(  # pylint: disable=inconsistent-return-statements
        self, indexer_name: str, *, x_ms_client_request_id: Optional[str] = None, **kwargs: Any
    ) -> None:
        """Resets the change tracking state associated with an indexer.

        :param indexer_name: The name of the indexer to reset. Required.
        :type indexer_name: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_indexers_reset_request(
            indexer_name=indexer_name,
            x_ms_client_request_id=x_ms_client_request_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @overload
    async def reset_docs(  # pylint: disable=inconsistent-return-statements
        self,
        indexer_name: str,
        keys_or_ids: Optional[JSON] = None,
        *,
        overwrite: bool = False,
        x_ms_client_request_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Resets specific documents in the datasource to be selectively re-ingested by the indexer.

        :param indexer_name: The name of the indexer to reset documents for. Required.
        :type indexer_name: str
        :param keys_or_ids: Default value is None.
        :type keys_or_ids: JSON
        :keyword overwrite: If false, keys or ids will be appended to existing ones. If true, only the
         keys or ids in this payload will be queued to be re-ingested. Default value is False.
        :paramtype overwrite: bool
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                keys_or_ids = {
                    "datasourceDocumentIds": [
                        "str"  # Optional. datasource document identifiers to be reset.
                    ],
                    "documentKeys": [
                        "str"  # Optional. document keys to be reset.
                    ]
                }
        """

    @overload
    async def reset_docs(  # pylint: disable=inconsistent-return-statements
        self,
        indexer_name: str,
        keys_or_ids: Optional[IO] = None,
        *,
        overwrite: bool = False,
        x_ms_client_request_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Resets specific documents in the datasource to be selectively re-ingested by the indexer.

        :param indexer_name: The name of the indexer to reset documents for. Required.
        :type indexer_name: str
        :param keys_or_ids: Default value is None.
        :type keys_or_ids: IO
        :keyword overwrite: If false, keys or ids will be appended to existing ones. If true, only the
         keys or ids in this payload will be queued to be re-ingested. Default value is False.
        :paramtype overwrite: bool
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def reset_docs(  # pylint: disable=inconsistent-return-statements
        self,
        indexer_name: str,
        keys_or_ids: Optional[Union[JSON, IO]] = None,
        *,
        overwrite: bool = False,
        x_ms_client_request_id: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """Resets specific documents in the datasource to be selectively re-ingested by the indexer.

        :param indexer_name: The name of the indexer to reset documents for. Required.
        :type indexer_name: str
        :param keys_or_ids: Is either a model type or a IO type. Default value is None.
        :type keys_or_ids: JSON or IO
        :keyword overwrite: If false, keys or ids will be appended to existing ones. If true, only the
         keys or ids in this payload will be queued to be re-ingested. Default value is False.
        :paramtype overwrite: bool
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(keys_or_ids, (IO, bytes)):
            _content = keys_or_ids
        else:
            if keys_or_ids is not None:
                _json = keys_or_ids
            else:
                _json = None

        request = build_indexers_reset_docs_request(
            indexer_name=indexer_name,
            overwrite=overwrite,
            x_ms_client_request_id=x_ms_client_request_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def run(  # pylint: disable=inconsistent-return-statements
        self, indexer_name: str, *, x_ms_client_request_id: Optional[str] = None, **kwargs: Any
    ) -> None:
        """Runs an indexer on-demand.

        :param indexer_name: The name of the indexer to run. Required.
        :type indexer_name: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_indexers_run_request(
            indexer_name=indexer_name,
            x_ms_client_request_id=x_ms_client_request_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @overload
    async def create_or_update(
        self,
        indexer_name: str,
        indexer: JSON,
        *,
        prefer: str,
        x_ms_client_request_id: Optional[str] = None,
        if_match: Optional[str] = None,
        if_none_match: Optional[str] = None,
        skip_indexer_reset_requirement_for_cache: Optional[bool] = None,
        disable_cache_reprocessing_change_detection: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new indexer or updates an indexer if it already exists.

        :param indexer_name: The name of the indexer to create or update. Required.
        :type indexer_name: str
        :param indexer: The definition of the indexer to create or update. Required.
        :type indexer: JSON
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword if_match: Defines the If-Match condition. The operation will be performed only if the
         ETag on the server matches this value. Default value is None.
        :paramtype if_match: str
        :keyword if_none_match: Defines the If-None-Match condition. The operation will be performed
         only if the ETag on the server does not match this value. Default value is None.
        :paramtype if_none_match: str
        :keyword skip_indexer_reset_requirement_for_cache: Ignores cache reset requirements. Default
         value is None.
        :paramtype skip_indexer_reset_requirement_for_cache: bool
        :keyword disable_cache_reprocessing_change_detection: Disables cache reprocessing change
         detection. Default value is None.
        :paramtype disable_cache_reprocessing_change_detection: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # JSON input template you can fill out and use as your body input.
                indexer = {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "cache": {
                        "enableReprocessing": bool,  # Optional. Specifies whether
                          incremental reprocessing is enabled.
                        "storageConnectionString": "str"  # Optional. The connection string
                          to the storage account where the cache data will be persisted.
                    },
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": False,  # Optional. Default value is False. A value indicating
                      whether the indexer is disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": False,  # Optional. Default
                              value is False. If true, will create a path //document//file_data that is
                              an object representing the original file data downloaded from your blob
                              data source.  This allows you to pass the original file data to a custom
                              skill for processing within the enrichment pipeline, or to the Document
                              Extraction skill.
                            "dataToExtract": "contentAndMetadata",  # Optional. Default
                              value is "contentAndMetadata". Specifies the data to extract from Azure
                              blob storage and tells the indexer which data to extract from image
                              content when "imageAction" is set to a value other than "none".  This
                              applies to embedded image content in a .PDF or other application, or
                              image files such as .jpg and .png, in Azure blobs. Known values are:
                              "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "",  # Optional. Default value
                              is "". Comma-delimited list of filename extensions to ignore when
                              processing from Azure blob storage.  For example, you could exclude
                              ".png, .mp4" to skip over those files during indexing.
                            "executionEnvironment": "standard",  # Optional. Default
                              value is "standard". Specifies the environment in which the indexer
                              should execute. Known values are: "standard" and "private".
                            "failOnUnprocessableDocument": False,  # Optional. Default
                              value is False. For Azure blobs, set to false if you want to continue
                              indexing if a document fails indexing.
                            "failOnUnsupportedContentType": False,  # Optional. Default
                              value is False. For Azure blobs, set to false if you want to continue
                              indexing when an unsupported content type is encountered, and you don't
                              know all the content types (file extensions) in advance.
                            "firstLineContainsHeaders": True,  # Optional. Default value
                              is True. For CSV blobs, indicates that the first (non-blank) line of each
                              blob contains headers.
                            "imageAction": "none",  # Optional. Default value is "none".
                              Determines how to process embedded images and image files in Azure blob
                              storage.  Setting the "imageAction" configuration to any value other than
                              "none" requires that a skillset also be attached to that indexer. Known
                              values are: "none", "generateNormalizedImages", and
                              "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": False,  #
                              Optional. Default value is False. For Azure blobs, set this property to
                              true to still index storage metadata for blob content that is too large
                              to process. Oversized blobs are treated as errors by default. For limits
                              on blob size, see
                              https://docs.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "",  # Optional. Default value
                              is "". Comma-delimited list of filename extensions to select when
                              processing from Azure blob storage.  For example, you could focus
                              indexing on specific application files ".docx, .pptx, .msg" to
                              specifically include those file types.
                            "parsingMode": "default",  # Optional. Default value is
                              "default". Represents the parsing mode for indexing from an Azure blob
                              data source. Known values are: "default", "text", "delimitedText",
                              "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "none",  # Optional. Default
                              value is "none". Determines algorithm for text extraction from PDF files
                              in Azure blob storage. Known values are: "none" and "detectAngles".
                            "queryTimeout": "00:05:00"  # Optional. Default value is
                              "00:05:00". Increases the timeout beyond the 5-minute default for Azure
                              SQL database data sources, specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. Default value is 0. The maximum
                          number of items that can fail indexing for indexer execution to still be
                          considered successful. -1 means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. Default value is 0. The
                          maximum number of items in a single batch that can fail indexing for the
                          batch to still be considered successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # response body for status code(s): 200, 201
                response == {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "cache": {
                        "enableReprocessing": bool,  # Optional. Specifies whether
                          incremental reprocessing is enabled.
                        "storageConnectionString": "str"  # Optional. The connection string
                          to the storage account where the cache data will be persisted.
                    },
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": False,  # Optional. Default value is False. A value indicating
                      whether the indexer is disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": False,  # Optional. Default
                              value is False. If true, will create a path //document//file_data that is
                              an object representing the original file data downloaded from your blob
                              data source.  This allows you to pass the original file data to a custom
                              skill for processing within the enrichment pipeline, or to the Document
                              Extraction skill.
                            "dataToExtract": "contentAndMetadata",  # Optional. Default
                              value is "contentAndMetadata". Specifies the data to extract from Azure
                              blob storage and tells the indexer which data to extract from image
                              content when "imageAction" is set to a value other than "none".  This
                              applies to embedded image content in a .PDF or other application, or
                              image files such as .jpg and .png, in Azure blobs. Known values are:
                              "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "",  # Optional. Default value
                              is "". Comma-delimited list of filename extensions to ignore when
                              processing from Azure blob storage.  For example, you could exclude
                              ".png, .mp4" to skip over those files during indexing.
                            "executionEnvironment": "standard",  # Optional. Default
                              value is "standard". Specifies the environment in which the indexer
                              should execute. Known values are: "standard" and "private".
                            "failOnUnprocessableDocument": False,  # Optional. Default
                              value is False. For Azure blobs, set to false if you want to continue
                              indexing if a document fails indexing.
                            "failOnUnsupportedContentType": False,  # Optional. Default
                              value is False. For Azure blobs, set to false if you want to continue
                              indexing when an unsupported content type is encountered, and you don't
                              know all the content types (file extensions) in advance.
                            "firstLineContainsHeaders": True,  # Optional. Default value
                              is True. For CSV blobs, indicates that the first (non-blank) line of each
                              blob contains headers.
                            "imageAction": "none",  # Optional. Default value is "none".
                              Determines how to process embedded images and image files in Azure blob
                              storage.  Setting the "imageAction" configuration to any value other than
                              "none" requires that a skillset also be attached to that indexer. Known
                              values are: "none", "generateNormalizedImages", and
                              "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": False,  #
                              Optional. Default value is False. For Azure blobs, set this property to
                              true to still index storage metadata for blob content that is too large
                              to process. Oversized blobs are treated as errors by default. For limits
                              on blob size, see
                              https://docs.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "",  # Optional. Default value
                              is "". Comma-delimited list of filename extensions to select when
                              processing from Azure blob storage.  For example, you could focus
                              indexing on specific application files ".docx, .pptx, .msg" to
                              specifically include those file types.
                            "parsingMode": "default",  # Optional. Default value is
                              "default". Represents the parsing mode for indexing from an Azure blob
                              data source. Known values are: "default", "text", "delimitedText",
                              "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "none",  # Optional. Default
                              value is "none". Determines algorithm for text extraction from PDF files
                              in Azure blob storage. Known values are: "none" and "detectAngles".
                            "queryTimeout": "00:05:00"  # Optional. Default value is
                              "00:05:00". Increases the timeout beyond the 5-minute default for Azure
                              SQL database data sources, specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. Default value is 0. The maximum
                          number of items that can fail indexing for indexer execution to still be
                          considered successful. -1 means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. Default value is 0. The
                          maximum number of items in a single batch that can fail indexing for the
                          batch to still be considered successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }
        """

    @overload
    async def create_or_update(
        self,
        indexer_name: str,
        indexer: IO,
        *,
        prefer: str,
        x_ms_client_request_id: Optional[str] = None,
        if_match: Optional[str] = None,
        if_none_match: Optional[str] = None,
        skip_indexer_reset_requirement_for_cache: Optional[bool] = None,
        disable_cache_reprocessing_change_detection: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new indexer or updates an indexer if it already exists.

        :param indexer_name: The name of the indexer to create or update. Required.
        :type indexer_name: str
        :param indexer: The definition of the indexer to create or update. Required.
        :type indexer: IO
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword if_match: Defines the If-Match condition. The operation will be performed only if the
         ETag on the server matches this value. Default value is None.
        :paramtype if_match: str
        :keyword if_none_match: Defines the If-None-Match condition. The operation will be performed
         only if the ETag on the server does not match this value. Default value is None.
        :paramtype if_none_match: str
        :keyword skip_indexer_reset_requirement_for_cache: Ignores cache reset requirements. Default
         value is None.
        :paramtype skip_indexer_reset_requirement_for_cache: bool
        :keyword disable_cache_reprocessing_change_detection: Disables cache reprocessing change
         detection. Default value is None.
        :paramtype disable_cache_reprocessing_change_detection: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # response body for status code(s): 200, 201
                response == {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "cache": {
                        "enableReprocessing": bool,  # Optional. Specifies whether
                          incremental reprocessing is enabled.
                        "storageConnectionString": "str"  # Optional. The connection string
                          to the storage account where the cache data will be persisted.
                    },
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": False,  # Optional. Default value is False. A value indicating
                      whether the indexer is disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": False,  # Optional. Default
                              value is False. If true, will create a path //document//file_data that is
                              an object representing the original file data downloaded from your blob
                              data source.  This allows you to pass the original file data to a custom
                              skill for processing within the enrichment pipeline, or to the Document
                              Extraction skill.
                            "dataToExtract": "contentAndMetadata",  # Optional. Default
                              value is "contentAndMetadata". Specifies the data to extract from Azure
                              blob storage and tells the indexer which data to extract from image
                              content when "imageAction" is set to a value other than "none".  This
                              applies to embedded image content in a .PDF or other application, or
                              image files such as .jpg and .png, in Azure blobs. Known values are:
                              "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "",  # Optional. Default value
                              is "". Comma-delimited list of filename extensions to ignore when
                              processing from Azure blob storage.  For example, you could exclude
                              ".png, .mp4" to skip over those files during indexing.
                            "executionEnvironment": "standard",  # Optional. Default
                              value is "standard". Specifies the environment in which the indexer
                              should execute. Known values are: "standard" and "private".
                            "failOnUnprocessableDocument": False,  # Optional. Default
                              value is False. For Azure blobs, set to false if you want to continue
                              indexing if a document fails indexing.
                            "failOnUnsupportedContentType": False,  # Optional. Default
                              value is False. For Azure blobs, set to false if you want to continue
                              indexing when an unsupported content type is encountered, and you don't
                              know all the content types (file extensions) in advance.
                            "firstLineContainsHeaders": True,  # Optional. Default value
                              is True. For CSV blobs, indicates that the first (non-blank) line of each
                              blob contains headers.
                            "imageAction": "none",  # Optional. Default value is "none".
                              Determines how to process embedded images and image files in Azure blob
                              storage.  Setting the "imageAction" configuration to any value other than
                              "none" requires that a skillset also be attached to that indexer. Known
                              values are: "none", "generateNormalizedImages", and
                              "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": False,  #
                              Optional. Default value is False. For Azure blobs, set this property to
                              true to still index storage metadata for blob content that is too large
                              to process. Oversized blobs are treated as errors by default. For limits
                              on blob size, see
                              https://docs.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "",  # Optional. Default value
                              is "". Comma-delimited list of filename extensions to select when
                              processing from Azure blob storage.  For example, you could focus
                              indexing on specific application files ".docx, .pptx, .msg" to
                              specifically include those file types.
                            "parsingMode": "default",  # Optional. Default value is
                              "default". Represents the parsing mode for indexing from an Azure blob
                              data source. Known values are: "default", "text", "delimitedText",
                              "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "none",  # Optional. Default
                              value is "none". Determines algorithm for text extraction from PDF files
                              in Azure blob storage. Known values are: "none" and "detectAngles".
                            "queryTimeout": "00:05:00"  # Optional. Default value is
                              "00:05:00". Increases the timeout beyond the 5-minute default for Azure
                              SQL database data sources, specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. Default value is 0. The maximum
                          number of items that can fail indexing for indexer execution to still be
                          considered successful. -1 means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. Default value is 0. The
                          maximum number of items in a single batch that can fail indexing for the
                          batch to still be considered successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }
        """

    @distributed_trace_async
    async def create_or_update(
        self,
        indexer_name: str,
        indexer: Union[JSON, IO],
        *,
        prefer: str,
        x_ms_client_request_id: Optional[str] = None,
        if_match: Optional[str] = None,
        if_none_match: Optional[str] = None,
        skip_indexer_reset_requirement_for_cache: Optional[bool] = None,
        disable_cache_reprocessing_change_detection: Optional[bool] = None,
        **kwargs: Any
    ) -> JSON:
        """Creates a new indexer or updates an indexer if it already exists.

        :param indexer_name: The name of the indexer to create or update. Required.
        :type indexer_name: str
        :param indexer: The definition of the indexer to create or update. Is either a model type or a
         IO type. Required.
        :type indexer: JSON or IO
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword if_match: Defines the If-Match condition. The operation will be performed only if the
         ETag on the server matches this value. Default value is None.
        :paramtype if_match: str
        :keyword if_none_match: Defines the If-None-Match condition. The operation will be performed
         only if the ETag on the server does not match this value. Default value is None.
        :paramtype if_none_match: str
        :keyword skip_indexer_reset_requirement_for_cache: Ignores cache reset requirements. Default
         value is None.
        :paramtype skip_indexer_reset_requirement_for_cache: bool
        :keyword disable_cache_reprocessing_change_detection: Disables cache reprocessing change
         detection. Default value is None.
        :paramtype disable_cache_reprocessing_change_detection: bool
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # response body for status code(s): 200, 201
                response == {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "cache": {
                        "enableReprocessing": bool,  # Optional. Specifies whether
                          incremental reprocessing is enabled.
                        "storageConnectionString": "str"  # Optional. The connection string
                          to the storage account where the cache data will be persisted.
                    },
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": False,  # Optional. Default value is False. A value indicating
                      whether the indexer is disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": False,  # Optional. Default
                              value is False. If true, will create a path //document//file_data that is
                              an object representing the original file data downloaded from your blob
                              data source.  This allows you to pass the original file data to a custom
                              skill for processing within the enrichment pipeline, or to the Document
                              Extraction skill.
                            "dataToExtract": "contentAndMetadata",  # Optional. Default
                              value is "contentAndMetadata". Specifies the data to extract from Azure
                              blob storage and tells the indexer which data to extract from image
                              content when "imageAction" is set to a value other than "none".  This
                              applies to embedded image content in a .PDF or other application, or
                              image files such as .jpg and .png, in Azure blobs. Known values are:
                              "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "",  # Optional. Default value
                              is "". Comma-delimited list of filename extensions to ignore when
                              processing from Azure blob storage.  For example, you could exclude
                              ".png, .mp4" to skip over those files during indexing.
                            "executionEnvironment": "standard",  # Optional. Default
                              value is "standard". Specifies the environment in which the indexer
                              should execute. Known values are: "standard" and "private".
                            "failOnUnprocessableDocument": False,  # Optional. Default
                              value is False. For Azure blobs, set to false if you want to continue
                              indexing if a document fails indexing.
                            "failOnUnsupportedContentType": False,  # Optional. Default
                              value is False. For Azure blobs, set to false if you want to continue
                              indexing when an unsupported content type is encountered, and you don't
                              know all the content types (file extensions) in advance.
                            "firstLineContainsHeaders": True,  # Optional. Default value
                              is True. For CSV blobs, indicates that the first (non-blank) line of each
                              blob contains headers.
                            "imageAction": "none",  # Optional. Default value is "none".
                              Determines how to process embedded images and image files in Azure blob
                              storage.  Setting the "imageAction" configuration to any value other than
                              "none" requires that a skillset also be attached to that indexer. Known
                              values are: "none", "generateNormalizedImages", and
                              "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": False,  #
                              Optional. Default value is False. For Azure blobs, set this property to
                              true to still index storage metadata for blob content that is too large
                              to process. Oversized blobs are treated as errors by default. For limits
                              on blob size, see
                              https://docs.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "",  # Optional. Default value
                              is "". Comma-delimited list of filename extensions to select when
                              processing from Azure blob storage.  For example, you could focus
                              indexing on specific application files ".docx, .pptx, .msg" to
                              specifically include those file types.
                            "parsingMode": "default",  # Optional. Default value is
                              "default". Represents the parsing mode for indexing from an Azure blob
                              data source. Known values are: "default", "text", "delimitedText",
                              "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "none",  # Optional. Default
                              value is "none". Determines algorithm for text extraction from PDF files
                              in Azure blob storage. Known values are: "none" and "detectAngles".
                            "queryTimeout": "00:05:00"  # Optional. Default value is
                              "00:05:00". Increases the timeout beyond the 5-minute default for Azure
                              SQL database data sources, specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. Default value is 0. The maximum
                          number of items that can fail indexing for indexer execution to still be
                          considered successful. -1 means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. Default value is 0. The
                          maximum number of items in a single batch that can fail indexing for the
                          batch to still be considered successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(indexer, (IO, bytes)):
            _content = indexer
        else:
            _json = indexer

        request = build_indexers_create_or_update_request(
            indexer_name=indexer_name,
            prefer=prefer,
            x_ms_client_request_id=x_ms_client_request_id,
            if_match=if_match,
            if_none_match=if_none_match,
            skip_indexer_reset_requirement_for_cache=skip_indexer_reset_requirement_for_cache,
            disable_cache_reprocessing_change_detection=disable_cache_reprocessing_change_detection,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def delete(  # pylint: disable=inconsistent-return-statements
        self,
        indexer_name: str,
        *,
        x_ms_client_request_id: Optional[str] = None,
        if_match: Optional[str] = None,
        if_none_match: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """Deletes an indexer.

        :param indexer_name: The name of the indexer to delete. Required.
        :type indexer_name: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword if_match: Defines the If-Match condition. The operation will be performed only if the
         ETag on the server matches this value. Default value is None.
        :paramtype if_match: str
        :keyword if_none_match: Defines the If-None-Match condition. The operation will be performed
         only if the ETag on the server does not match this value. Default value is None.
        :paramtype if_none_match: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_indexers_delete_request(
            indexer_name=indexer_name,
            x_ms_client_request_id=x_ms_client_request_id,
            if_match=if_match,
            if_none_match=if_none_match,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get(self, indexer_name: str, *, x_ms_client_request_id: Optional[str] = None, **kwargs: Any) -> JSON:
        """Retrieves an indexer definition.

        :param indexer_name: The name of the indexer to retrieve. Required.
        :type indexer_name: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # response body for status code(s): 200
                response == {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "cache": {
                        "enableReprocessing": bool,  # Optional. Specifies whether
                          incremental reprocessing is enabled.
                        "storageConnectionString": "str"  # Optional. The connection string
                          to the storage account where the cache data will be persisted.
                    },
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": False,  # Optional. Default value is False. A value indicating
                      whether the indexer is disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": False,  # Optional. Default
                              value is False. If true, will create a path //document//file_data that is
                              an object representing the original file data downloaded from your blob
                              data source.  This allows you to pass the original file data to a custom
                              skill for processing within the enrichment pipeline, or to the Document
                              Extraction skill.
                            "dataToExtract": "contentAndMetadata",  # Optional. Default
                              value is "contentAndMetadata". Specifies the data to extract from Azure
                              blob storage and tells the indexer which data to extract from image
                              content when "imageAction" is set to a value other than "none".  This
                              applies to embedded image content in a .PDF or other application, or
                              image files such as .jpg and .png, in Azure blobs. Known values are:
                              "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "",  # Optional. Default value
                              is "". Comma-delimited list of filename extensions to ignore when
                              processing from Azure blob storage.  For example, you could exclude
                              ".png, .mp4" to skip over those files during indexing.
                            "executionEnvironment": "standard",  # Optional. Default
                              value is "standard". Specifies the environment in which the indexer
                              should execute. Known values are: "standard" and "private".
                            "failOnUnprocessableDocument": False,  # Optional. Default
                              value is False. For Azure blobs, set to false if you want to continue
                              indexing if a document fails indexing.
                            "failOnUnsupportedContentType": False,  # Optional. Default
                              value is False. For Azure blobs, set to false if you want to continue
                              indexing when an unsupported content type is encountered, and you don't
                              know all the content types (file extensions) in advance.
                            "firstLineContainsHeaders": True,  # Optional. Default value
                              is True. For CSV blobs, indicates that the first (non-blank) line of each
                              blob contains headers.
                            "imageAction": "none",  # Optional. Default value is "none".
                              Determines how to process embedded images and image files in Azure blob
                              storage.  Setting the "imageAction" configuration to any value other than
                              "none" requires that a skillset also be attached to that indexer. Known
                              values are: "none", "generateNormalizedImages", and
                              "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": False,  #
                              Optional. Default value is False. For Azure blobs, set this property to
                              true to still index storage metadata for blob content that is too large
                              to process. Oversized blobs are treated as errors by default. For limits
                              on blob size, see
                              https://docs.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "",  # Optional. Default value
                              is "". Comma-delimited list of filename extensions to select when
                              processing from Azure blob storage.  For example, you could focus
                              indexing on specific application files ".docx, .pptx, .msg" to
                              specifically include those file types.
                            "parsingMode": "default",  # Optional. Default value is
                              "default". Represents the parsing mode for indexing from an Azure blob
                              data source. Known values are: "default", "text", "delimitedText",
                              "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "none",  # Optional. Default
                              value is "none". Determines algorithm for text extraction from PDF files
                              in Azure blob storage. Known values are: "none" and "detectAngles".
                            "queryTimeout": "00:05:00"  # Optional. Default value is
                              "00:05:00". Increases the timeout beyond the 5-minute default for Azure
                              SQL database data sources, specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. Default value is 0. The maximum
                          number of items that can fail indexing for indexer execution to still be
                          considered successful. -1 means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. Default value is 0. The
                          maximum number of items in a single batch that can fail indexing for the
                          batch to still be considered successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_indexers_get_request(
            indexer_name=indexer_name,
            x_ms_client_request_id=x_ms_client_request_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def list(
        self, *, select: Optional[str] = None, x_ms_client_request_id: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Lists all indexers available for a search service.

        :keyword select: Selects which top-level properties of the indexers to retrieve. Specified as a
         comma-separated list of JSON property names, or '*' for all properties. The default is all
         properties. Default value is None.
        :paramtype select: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "dataSourceName": "str",  # The name of the datasource from
                              which this indexer reads data. Required.
                            "name": "str",  # The name of the indexer. Required.
                            "targetIndexName": "str",  # The name of the index to which
                              this indexer writes data. Required.
                            "@odata.etag": "str",  # Optional. The ETag of the indexer.
                            "cache": {
                                "enableReprocessing": bool,  # Optional. Specifies
                                  whether incremental reprocessing is enabled.
                                "storageConnectionString": "str"  # Optional. The
                                  connection string to the storage account where the cache data will be
                                  persisted.
                            },
                            "description": "str",  # Optional. The description of the
                              indexer.
                            "disabled": False,  # Optional. Default value is False. A
                              value indicating whether the indexer is disabled. Default is false.
                            "encryptionKey": {
                                "keyVaultKeyName": "str",  # The name of your Azure
                                  Key Vault key to be used to encrypt your data at rest. Required.
                                "keyVaultKeyVersion": "str",  # The version of your
                                  Azure Key Vault key to be used to encrypt your data at rest.
                                  Required.
                                "keyVaultUri": "str",  # The URI of your Azure Key
                                  Vault, also referred to as DNS name, that contains the key to be used
                                  to encrypt your data at rest. An example URI might be
                                  https://my-keyvault-name.vault.azure.net. Required.
                                "accessCredentials": {
                                    "applicationId": "str",  # An AAD Application
                                      ID that was granted the required access permissions to the Azure
                                      Key Vault that is to be used when encrypting your data at rest.
                                      The Application ID should not be confused with the Object ID for
                                      your AAD Application. Required.
                                    "applicationSecret": "str"  # Optional. The
                                      authentication key of the specified AAD application.
                                },
                                "identity": search_indexer_data_identity
                            },
                            "fieldMappings": [
                                {
                                    "sourceFieldName": "str",  # The name of the
                                      field in the data source. Required.
                                    "mappingFunction": {
                                        "name": "str",  # The name of the
                                          field mapping function. Required.
                                        "parameters": {
                                            "str": {}  # Optional. A
                                              dictionary of parameter name/value pairs to pass to the
                                              function. Each value must be of a primitive type.
                                        }
                                    },
                                    "targetFieldName": "str"  # Optional. The
                                      name of the target field in the index. Same as the source field
                                      name by default.
                                }
                            ],
                            "outputFieldMappings": [
                                {
                                    "sourceFieldName": "str",  # The name of the
                                      field in the data source. Required.
                                    "mappingFunction": {
                                        "name": "str",  # The name of the
                                          field mapping function. Required.
                                        "parameters": {
                                            "str": {}  # Optional. A
                                              dictionary of parameter name/value pairs to pass to the
                                              function. Each value must be of a primitive type.
                                        }
                                    },
                                    "targetFieldName": "str"  # Optional. The
                                      name of the target field in the index. Same as the source field
                                      name by default.
                                }
                            ],
                            "parameters": {
                                "batchSize": 0,  # Optional. The number of items that
                                  are read from the data source and indexed as a single batch in order
                                  to improve performance. The default depends on the data source type.
                                "configuration": {
                                    "allowSkillsetToReadFileData": False,  #
                                      Optional. Default value is False. If true, will create a path
                                      //document//file_data that is an object representing the original
                                      file data downloaded from your blob data source.  This allows you
                                      to pass the original file data to a custom skill for processing
                                      within the enrichment pipeline, or to the Document Extraction
                                      skill.
                                    "dataToExtract": "contentAndMetadata",  #
                                      Optional. Default value is "contentAndMetadata". Specifies the
                                      data to extract from Azure blob storage and tells the indexer
                                      which data to extract from image content when "imageAction" is
                                      set to a value other than "none".  This applies to embedded image
                                      content in a .PDF or other application, or image files such as
                                      .jpg and .png, in Azure blobs. Known values are:
                                      "storageMetadata", "allMetadata", and "contentAndMetadata".
                                    "delimitedTextDelimiter": "str",  # Optional.
                                      For CSV blobs, specifies the end-of-line single-character
                                      delimiter for CSV files where each line starts a new document
                                      (for example, "|").
                                    "delimitedTextHeaders": "str",  # Optional.
                                      For CSV blobs, specifies a comma-delimited list of column
                                      headers, useful for mapping source fields to destination fields
                                      in an index.
                                    "documentRoot": "str",  # Optional. For JSON
                                      arrays, given a structured or semi-structured document, you can
                                      specify a path to the array using this property.
                                    "excludedFileNameExtensions": "",  #
                                      Optional. Default value is "". Comma-delimited list of filename
                                      extensions to ignore when processing from Azure blob storage.
                                      For example, you could exclude ".png, .mp4" to skip over those
                                      files during indexing.
                                    "executionEnvironment": "standard",  #
                                      Optional. Default value is "standard". Specifies the environment
                                      in which the indexer should execute. Known values are: "standard"
                                      and "private".
                                    "failOnUnprocessableDocument": False,  #
                                      Optional. Default value is False. For Azure blobs, set to false
                                      if you want to continue indexing if a document fails indexing.
                                    "failOnUnsupportedContentType": False,  #
                                      Optional. Default value is False. For Azure blobs, set to false
                                      if you want to continue indexing when an unsupported content type
                                      is encountered, and you don't know all the content types (file
                                      extensions) in advance.
                                    "firstLineContainsHeaders": True,  #
                                      Optional. Default value is True. For CSV blobs, indicates that
                                      the first (non-blank) line of each blob contains headers.
                                    "imageAction": "none",  # Optional. Default
                                      value is "none". Determines how to process embedded images and
                                      image files in Azure blob storage.  Setting the "imageAction"
                                      configuration to any value other than "none" requires that a
                                      skillset also be attached to that indexer. Known values are:
                                      "none", "generateNormalizedImages", and
                                      "generateNormalizedImagePerPage".
                "indexStorageMetadataOnlyForOversizedDocuments": False,  #
                                      Optional. Default value is False. For Azure blobs, set this
                                      property to true to still index storage metadata for blob content
                                      that is too large to process. Oversized blobs are treated as
                                      errors by default. For limits on blob size, see
                                      https://docs.microsoft.com/azure/search/search-limits-quotas-capacity.
                                    "indexedFileNameExtensions": "",  # Optional.
                                      Default value is "". Comma-delimited list of filename extensions
                                      to select when processing from Azure blob storage.  For example,
                                      you could focus indexing on specific application files ".docx,
                                      .pptx, .msg" to specifically include those file types.
                                    "parsingMode": "default",  # Optional.
                                      Default value is "default". Represents the parsing mode for
                                      indexing from an Azure blob data source. Known values are:
                                      "default", "text", "delimitedText", "json", "jsonArray", and
                                      "jsonLines".
                                    "pdfTextRotationAlgorithm": "none",  #
                                      Optional. Default value is "none". Determines algorithm for text
                                      extraction from PDF files in Azure blob storage. Known values
                                      are: "none" and "detectAngles".
                                    "queryTimeout": "00:05:00"  # Optional.
                                      Default value is "00:05:00". Increases the timeout beyond the
                                      5-minute default for Azure SQL database data sources, specified
                                      in the format "hh:mm:ss".
                                },
                                "maxFailedItems": 0,  # Optional. Default value is 0.
                                  The maximum number of items that can fail indexing for indexer
                                  execution to still be considered successful. -1 means no limit.
                                  Default is 0.
                                "maxFailedItemsPerBatch": 0  # Optional. Default
                                  value is 0. The maximum number of items in a single batch that can
                                  fail indexing for the batch to still be considered successful. -1
                                  means no limit. Default is 0.
                            },
                            "schedule": {
                                "interval": "1 day, 0:00:00",  # The interval of time
                                  between indexer executions. Required.
                                "startTime": "2020-02-20 00:00:00"  # Optional. The
                                  time when an indexer should start running.
                            },
                            "skillsetName": "str"  # Optional. The name of the skillset
                              executing with this indexer.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_indexers_list_request(
            select=select,
            x_ms_client_request_id=x_ms_client_request_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def create(
        self,
        indexer: JSON,
        *,
        x_ms_client_request_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new indexer.

        :param indexer: The definition of the indexer to create. Required.
        :type indexer: JSON
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # JSON input template you can fill out and use as your body input.
                indexer = {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "cache": {
                        "enableReprocessing": bool,  # Optional. Specifies whether
                          incremental reprocessing is enabled.
                        "storageConnectionString": "str"  # Optional. The connection string
                          to the storage account where the cache data will be persisted.
                    },
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": False,  # Optional. Default value is False. A value indicating
                      whether the indexer is disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": False,  # Optional. Default
                              value is False. If true, will create a path //document//file_data that is
                              an object representing the original file data downloaded from your blob
                              data source.  This allows you to pass the original file data to a custom
                              skill for processing within the enrichment pipeline, or to the Document
                              Extraction skill.
                            "dataToExtract": "contentAndMetadata",  # Optional. Default
                              value is "contentAndMetadata". Specifies the data to extract from Azure
                              blob storage and tells the indexer which data to extract from image
                              content when "imageAction" is set to a value other than "none".  This
                              applies to embedded image content in a .PDF or other application, or
                              image files such as .jpg and .png, in Azure blobs. Known values are:
                              "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "",  # Optional. Default value
                              is "". Comma-delimited list of filename extensions to ignore when
                              processing from Azure blob storage.  For example, you could exclude
                              ".png, .mp4" to skip over those files during indexing.
                            "executionEnvironment": "standard",  # Optional. Default
                              value is "standard". Specifies the environment in which the indexer
                              should execute. Known values are: "standard" and "private".
                            "failOnUnprocessableDocument": False,  # Optional. Default
                              value is False. For Azure blobs, set to false if you want to continue
                              indexing if a document fails indexing.
                            "failOnUnsupportedContentType": False,  # Optional. Default
                              value is False. For Azure blobs, set to false if you want to continue
                              indexing when an unsupported content type is encountered, and you don't
                              know all the content types (file extensions) in advance.
                            "firstLineContainsHeaders": True,  # Optional. Default value
                              is True. For CSV blobs, indicates that the first (non-blank) line of each
                              blob contains headers.
                            "imageAction": "none",  # Optional. Default value is "none".
                              Determines how to process embedded images and image files in Azure blob
                              storage.  Setting the "imageAction" configuration to any value other than
                              "none" requires that a skillset also be attached to that indexer. Known
                              values are: "none", "generateNormalizedImages", and
                              "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": False,  #
                              Optional. Default value is False. For Azure blobs, set this property to
                              true to still index storage metadata for blob content that is too large
                              to process. Oversized blobs are treated as errors by default. For limits
                              on blob size, see
                              https://docs.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "",  # Optional. Default value
                              is "". Comma-delimited list of filename extensions to select when
                              processing from Azure blob storage.  For example, you could focus
                              indexing on specific application files ".docx, .pptx, .msg" to
                              specifically include those file types.
                            "parsingMode": "default",  # Optional. Default value is
                              "default". Represents the parsing mode for indexing from an Azure blob
                              data source. Known values are: "default", "text", "delimitedText",
                              "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "none",  # Optional. Default
                              value is "none". Determines algorithm for text extraction from PDF files
                              in Azure blob storage. Known values are: "none" and "detectAngles".
                            "queryTimeout": "00:05:00"  # Optional. Default value is
                              "00:05:00". Increases the timeout beyond the 5-minute default for Azure
                              SQL database data sources, specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. Default value is 0. The maximum
                          number of items that can fail indexing for indexer execution to still be
                          considered successful. -1 means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. Default value is 0. The
                          maximum number of items in a single batch that can fail indexing for the
                          batch to still be considered successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # response body for status code(s): 201
                response == {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "cache": {
                        "enableReprocessing": bool,  # Optional. Specifies whether
                          incremental reprocessing is enabled.
                        "storageConnectionString": "str"  # Optional. The connection string
                          to the storage account where the cache data will be persisted.
                    },
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": False,  # Optional. Default value is False. A value indicating
                      whether the indexer is disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": False,  # Optional. Default
                              value is False. If true, will create a path //document//file_data that is
                              an object representing the original file data downloaded from your blob
                              data source.  This allows you to pass the original file data to a custom
                              skill for processing within the enrichment pipeline, or to the Document
                              Extraction skill.
                            "dataToExtract": "contentAndMetadata",  # Optional. Default
                              value is "contentAndMetadata". Specifies the data to extract from Azure
                              blob storage and tells the indexer which data to extract from image
                              content when "imageAction" is set to a value other than "none".  This
                              applies to embedded image content in a .PDF or other application, or
                              image files such as .jpg and .png, in Azure blobs. Known values are:
                              "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "",  # Optional. Default value
                              is "". Comma-delimited list of filename extensions to ignore when
                              processing from Azure blob storage.  For example, you could exclude
                              ".png, .mp4" to skip over those files during indexing.
                            "executionEnvironment": "standard",  # Optional. Default
                              value is "standard". Specifies the environment in which the indexer
                              should execute. Known values are: "standard" and "private".
                            "failOnUnprocessableDocument": False,  # Optional. Default
                              value is False. For Azure blobs, set to false if you want to continue
                              indexing if a document fails indexing.
                            "failOnUnsupportedContentType": False,  # Optional. Default
                              value is False. For Azure blobs, set to false if you want to continue
                              indexing when an unsupported content type is encountered, and you don't
                              know all the content types (file extensions) in advance.
                            "firstLineContainsHeaders": True,  # Optional. Default value
                              is True. For CSV blobs, indicates that the first (non-blank) line of each
                              blob contains headers.
                            "imageAction": "none",  # Optional. Default value is "none".
                              Determines how to process embedded images and image files in Azure blob
                              storage.  Setting the "imageAction" configuration to any value other than
                              "none" requires that a skillset also be attached to that indexer. Known
                              values are: "none", "generateNormalizedImages", and
                              "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": False,  #
                              Optional. Default value is False. For Azure blobs, set this property to
                              true to still index storage metadata for blob content that is too large
                              to process. Oversized blobs are treated as errors by default. For limits
                              on blob size, see
                              https://docs.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "",  # Optional. Default value
                              is "". Comma-delimited list of filename extensions to select when
                              processing from Azure blob storage.  For example, you could focus
                              indexing on specific application files ".docx, .pptx, .msg" to
                              specifically include those file types.
                            "parsingMode": "default",  # Optional. Default value is
                              "default". Represents the parsing mode for indexing from an Azure blob
                              data source. Known values are: "default", "text", "delimitedText",
                              "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "none",  # Optional. Default
                              value is "none". Determines algorithm for text extraction from PDF files
                              in Azure blob storage. Known values are: "none" and "detectAngles".
                            "queryTimeout": "00:05:00"  # Optional. Default value is
                              "00:05:00". Increases the timeout beyond the 5-minute default for Azure
                              SQL database data sources, specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. Default value is 0. The maximum
                          number of items that can fail indexing for indexer execution to still be
                          considered successful. -1 means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. Default value is 0. The
                          maximum number of items in a single batch that can fail indexing for the
                          batch to still be considered successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }
        """

    @overload
    async def create(
        self,
        indexer: IO,
        *,
        x_ms_client_request_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new indexer.

        :param indexer: The definition of the indexer to create. Required.
        :type indexer: IO
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # response body for status code(s): 201
                response == {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "cache": {
                        "enableReprocessing": bool,  # Optional. Specifies whether
                          incremental reprocessing is enabled.
                        "storageConnectionString": "str"  # Optional. The connection string
                          to the storage account where the cache data will be persisted.
                    },
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": False,  # Optional. Default value is False. A value indicating
                      whether the indexer is disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": False,  # Optional. Default
                              value is False. If true, will create a path //document//file_data that is
                              an object representing the original file data downloaded from your blob
                              data source.  This allows you to pass the original file data to a custom
                              skill for processing within the enrichment pipeline, or to the Document
                              Extraction skill.
                            "dataToExtract": "contentAndMetadata",  # Optional. Default
                              value is "contentAndMetadata". Specifies the data to extract from Azure
                              blob storage and tells the indexer which data to extract from image
                              content when "imageAction" is set to a value other than "none".  This
                              applies to embedded image content in a .PDF or other application, or
                              image files such as .jpg and .png, in Azure blobs. Known values are:
                              "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "",  # Optional. Default value
                              is "". Comma-delimited list of filename extensions to ignore when
                              processing from Azure blob storage.  For example, you could exclude
                              ".png, .mp4" to skip over those files during indexing.
                            "executionEnvironment": "standard",  # Optional. Default
                              value is "standard". Specifies the environment in which the indexer
                              should execute. Known values are: "standard" and "private".
                            "failOnUnprocessableDocument": False,  # Optional. Default
                              value is False. For Azure blobs, set to false if you want to continue
                              indexing if a document fails indexing.
                            "failOnUnsupportedContentType": False,  # Optional. Default
                              value is False. For Azure blobs, set to false if you want to continue
                              indexing when an unsupported content type is encountered, and you don't
                              know all the content types (file extensions) in advance.
                            "firstLineContainsHeaders": True,  # Optional. Default value
                              is True. For CSV blobs, indicates that the first (non-blank) line of each
                              blob contains headers.
                            "imageAction": "none",  # Optional. Default value is "none".
                              Determines how to process embedded images and image files in Azure blob
                              storage.  Setting the "imageAction" configuration to any value other than
                              "none" requires that a skillset also be attached to that indexer. Known
                              values are: "none", "generateNormalizedImages", and
                              "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": False,  #
                              Optional. Default value is False. For Azure blobs, set this property to
                              true to still index storage metadata for blob content that is too large
                              to process. Oversized blobs are treated as errors by default. For limits
                              on blob size, see
                              https://docs.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "",  # Optional. Default value
                              is "". Comma-delimited list of filename extensions to select when
                              processing from Azure blob storage.  For example, you could focus
                              indexing on specific application files ".docx, .pptx, .msg" to
                              specifically include those file types.
                            "parsingMode": "default",  # Optional. Default value is
                              "default". Represents the parsing mode for indexing from an Azure blob
                              data source. Known values are: "default", "text", "delimitedText",
                              "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "none",  # Optional. Default
                              value is "none". Determines algorithm for text extraction from PDF files
                              in Azure blob storage. Known values are: "none" and "detectAngles".
                            "queryTimeout": "00:05:00"  # Optional. Default value is
                              "00:05:00". Increases the timeout beyond the 5-minute default for Azure
                              SQL database data sources, specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. Default value is 0. The maximum
                          number of items that can fail indexing for indexer execution to still be
                          considered successful. -1 means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. Default value is 0. The
                          maximum number of items in a single batch that can fail indexing for the
                          batch to still be considered successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }
        """

    @distributed_trace_async
    async def create(
        self, indexer: Union[JSON, IO], *, x_ms_client_request_id: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Creates a new indexer.

        :param indexer: The definition of the indexer to create. Is either a model type or a IO type.
         Required.
        :type indexer: JSON or IO
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # response body for status code(s): 201
                response == {
                    "dataSourceName": "str",  # The name of the datasource from which this
                      indexer reads data. Required.
                    "name": "str",  # The name of the indexer. Required.
                    "targetIndexName": "str",  # The name of the index to which this indexer
                      writes data. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the indexer.
                    "cache": {
                        "enableReprocessing": bool,  # Optional. Specifies whether
                          incremental reprocessing is enabled.
                        "storageConnectionString": "str"  # Optional. The connection string
                          to the storage account where the cache data will be persisted.
                    },
                    "description": "str",  # Optional. The description of the indexer.
                    "disabled": False,  # Optional. Default value is False. A value indicating
                      whether the indexer is disabled. Default is false.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "fieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "outputFieldMappings": [
                        {
                            "sourceFieldName": "str",  # The name of the field in the
                              data source. Required.
                            "mappingFunction": {
                                "name": "str",  # The name of the field mapping
                                  function. Required.
                                "parameters": {
                                    "str": {}  # Optional. A dictionary of
                                      parameter name/value pairs to pass to the function. Each value
                                      must be of a primitive type.
                                }
                            },
                            "targetFieldName": "str"  # Optional. The name of the target
                              field in the index. Same as the source field name by default.
                        }
                    ],
                    "parameters": {
                        "batchSize": 0,  # Optional. The number of items that are read from
                          the data source and indexed as a single batch in order to improve
                          performance. The default depends on the data source type.
                        "configuration": {
                            "allowSkillsetToReadFileData": False,  # Optional. Default
                              value is False. If true, will create a path //document//file_data that is
                              an object representing the original file data downloaded from your blob
                              data source.  This allows you to pass the original file data to a custom
                              skill for processing within the enrichment pipeline, or to the Document
                              Extraction skill.
                            "dataToExtract": "contentAndMetadata",  # Optional. Default
                              value is "contentAndMetadata". Specifies the data to extract from Azure
                              blob storage and tells the indexer which data to extract from image
                              content when "imageAction" is set to a value other than "none".  This
                              applies to embedded image content in a .PDF or other application, or
                              image files such as .jpg and .png, in Azure blobs. Known values are:
                              "storageMetadata", "allMetadata", and "contentAndMetadata".
                            "delimitedTextDelimiter": "str",  # Optional. For CSV blobs,
                              specifies the end-of-line single-character delimiter for CSV files where
                              each line starts a new document (for example, "|").
                            "delimitedTextHeaders": "str",  # Optional. For CSV blobs,
                              specifies a comma-delimited list of column headers, useful for mapping
                              source fields to destination fields in an index.
                            "documentRoot": "str",  # Optional. For JSON arrays, given a
                              structured or semi-structured document, you can specify a path to the
                              array using this property.
                            "excludedFileNameExtensions": "",  # Optional. Default value
                              is "". Comma-delimited list of filename extensions to ignore when
                              processing from Azure blob storage.  For example, you could exclude
                              ".png, .mp4" to skip over those files during indexing.
                            "executionEnvironment": "standard",  # Optional. Default
                              value is "standard". Specifies the environment in which the indexer
                              should execute. Known values are: "standard" and "private".
                            "failOnUnprocessableDocument": False,  # Optional. Default
                              value is False. For Azure blobs, set to false if you want to continue
                              indexing if a document fails indexing.
                            "failOnUnsupportedContentType": False,  # Optional. Default
                              value is False. For Azure blobs, set to false if you want to continue
                              indexing when an unsupported content type is encountered, and you don't
                              know all the content types (file extensions) in advance.
                            "firstLineContainsHeaders": True,  # Optional. Default value
                              is True. For CSV blobs, indicates that the first (non-blank) line of each
                              blob contains headers.
                            "imageAction": "none",  # Optional. Default value is "none".
                              Determines how to process embedded images and image files in Azure blob
                              storage.  Setting the "imageAction" configuration to any value other than
                              "none" requires that a skillset also be attached to that indexer. Known
                              values are: "none", "generateNormalizedImages", and
                              "generateNormalizedImagePerPage".
                            "indexStorageMetadataOnlyForOversizedDocuments": False,  #
                              Optional. Default value is False. For Azure blobs, set this property to
                              true to still index storage metadata for blob content that is too large
                              to process. Oversized blobs are treated as errors by default. For limits
                              on blob size, see
                              https://docs.microsoft.com/azure/search/search-limits-quotas-capacity.
                            "indexedFileNameExtensions": "",  # Optional. Default value
                              is "". Comma-delimited list of filename extensions to select when
                              processing from Azure blob storage.  For example, you could focus
                              indexing on specific application files ".docx, .pptx, .msg" to
                              specifically include those file types.
                            "parsingMode": "default",  # Optional. Default value is
                              "default". Represents the parsing mode for indexing from an Azure blob
                              data source. Known values are: "default", "text", "delimitedText",
                              "json", "jsonArray", and "jsonLines".
                            "pdfTextRotationAlgorithm": "none",  # Optional. Default
                              value is "none". Determines algorithm for text extraction from PDF files
                              in Azure blob storage. Known values are: "none" and "detectAngles".
                            "queryTimeout": "00:05:00"  # Optional. Default value is
                              "00:05:00". Increases the timeout beyond the 5-minute default for Azure
                              SQL database data sources, specified in the format "hh:mm:ss".
                        },
                        "maxFailedItems": 0,  # Optional. Default value is 0. The maximum
                          number of items that can fail indexing for indexer execution to still be
                          considered successful. -1 means no limit. Default is 0.
                        "maxFailedItemsPerBatch": 0  # Optional. Default value is 0. The
                          maximum number of items in a single batch that can fail indexing for the
                          batch to still be considered successful. -1 means no limit. Default is 0.
                    },
                    "schedule": {
                        "interval": "1 day, 0:00:00",  # The interval of time between indexer
                          executions. Required.
                        "startTime": "2020-02-20 00:00:00"  # Optional. The time when an
                          indexer should start running.
                    },
                    "skillsetName": "str"  # Optional. The name of the skillset executing with
                      this indexer.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(indexer, (IO, bytes)):
            _content = indexer
        else:
            _json = indexer

        request = build_indexers_create_request(
            x_ms_client_request_id=x_ms_client_request_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def get_status(
        self, indexer_name: str, *, x_ms_client_request_id: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Returns the current status and execution history of an indexer.

        :param indexer_name: The name of the indexer for which to retrieve status. Required.
        :type indexer_name: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "executionHistory": [
                        {
                            "errors": [
                                {
                                    "errorMessage": "str",  # The message
                                      describing the error that occurred while processing the item.
                                      Required.
                                    "statusCode": 0,  # The status code
                                      indicating why the indexing operation failed. Possible values
                                      include: 400 for a malformed input document, 404 for document not
                                      found, 409 for a version conflict, 422 when the index is
                                      temporarily unavailable, or 503 for when the service is too busy.
                                      Required.
                                    "details": "str",  # Optional. Additional,
                                      verbose details about the error to assist in debugging the
                                      indexer. This may not be always available.
                                    "documentationLink": "str",  # Optional. A
                                      link to a troubleshooting guide for these classes of errors. This
                                      may not be always available.
                                    "key": "str",  # Optional. The key of the
                                      item for which indexing failed.
                                    "name": "str"  # Optional. The name of the
                                      source at which the error originated. For example, this could
                                      refer to a particular skill in the attached skillset. This may
                                      not be always available.
                                }
                            ],
                            "itemsFailed": 0,  # The number of items that failed to be
                              indexed during this indexer execution. Required.
                            "itemsProcessed": 0,  # The number of items that were
                              processed during this indexer execution. This includes both successfully
                              processed items and items where indexing was attempted but failed.
                              Required.
                            "status": "str",  # The outcome of this indexer execution.
                              Required. Known values are: "transientFailure", "success", "inProgress",
                              and "reset".
                            "warnings": [
                                {
                                    "message": "str",  # The message describing
                                      the warning that occurred while processing the item. Required.
                                    "details": "str",  # Optional. Additional,
                                      verbose details about the warning to assist in debugging the
                                      indexer. This may not be always available.
                                    "documentationLink": "str",  # Optional. A
                                      link to a troubleshooting guide for these classes of warnings.
                                      This may not be always available.
                                    "key": "str",  # Optional. The key of the
                                      item which generated a warning.
                                    "name": "str"  # Optional. The name of the
                                      source at which the warning originated. For example, this could
                                      refer to a particular skill in the attached skillset. This may
                                      not be always available.
                                }
                            ],
                            "currentState": {
                                "allDocsFinalChangeTrackingState": "str",  #
                                  Optional. Change tracking state value when indexing finishes on all
                                  documents in the datasource.
                                "allDocsInitialChangeTrackingState": "str",  #
                                  Optional. Change tracking state used when indexing starts on all
                                  documents in the datasource.
                                "mode": "str",  # Optional. The mode the indexer is
                                  running in. Known values are: "indexingAllDocs" and
                                  "indexingResetDocs".
                                "resetDatasourceDocumentIds": [
                                    "str"  # Optional. The list of datasource
                                      document ids that have been reset. The datasource document id is
                                      the unique identifier for the data in the datasource. The indexer
                                      will prioritize selectively re-ingesting these ids.
                                ],
                                "resetDocsFinalChangeTrackingState": "str",  #
                                  Optional. Change tracking state value when indexing finishes on
                                  select, reset documents in the datasource.
                                "resetDocsInitialChangeTrackingState": "str",  #
                                  Optional. Change tracking state used when indexing starts on select,
                                  reset documents in the datasource.
                                "resetDocumentKeys": [
                                    "str"  # Optional. The list of document keys
                                      that have been reset. The document key is the document's unique
                                      identifier for the data in the search index. The indexer will
                                      prioritize selectively re-ingesting these keys.
                                ]
                            },
                            "endTime": "2020-02-20 00:00:00",  # Optional. The end time
                              of this indexer execution, if the execution has already completed.
                            "errorMessage": "str",  # Optional. The error message
                              indicating the top-level error, if any.
                            "finalTrackingState": "str",  # Optional. Change tracking
                              state with which an indexer execution finished.
                            "initialTrackingState": "str",  # Optional. Change tracking
                              state with which an indexer execution started.
                            "startTime": "2020-02-20 00:00:00",  # Optional. The start
                              time of this indexer execution.
                            "statusDetail": "str"  # Optional. The outcome of this
                              indexer execution. "resetDocs"
                        }
                    ],
                    "limits": {
                        "maxDocumentContentCharactersToExtract": 0,  # Optional. The maximum
                          number of characters that will be extracted from a document picked up for
                          indexing.
                        "maxDocumentExtractionSize": 0,  # Optional. The maximum size of a
                          document, in bytes, which will be considered valid for indexing.
                        "maxRunTime": "1 day, 0:00:00"  # Optional. The maximum duration that
                          the indexer is permitted to run for one execution.
                    },
                    "status": "str",  # Overall indexer status. Required. Known values are:
                      "unknown", "error", and "running".
                    "lastResult": {
                        "errors": [
                            {
                                "errorMessage": "str",  # The message describing the
                                  error that occurred while processing the item. Required.
                                "statusCode": 0,  # The status code indicating why
                                  the indexing operation failed. Possible values include: 400 for a
                                  malformed input document, 404 for document not found, 409 for a
                                  version conflict, 422 when the index is temporarily unavailable, or
                                  503 for when the service is too busy. Required.
                                "details": "str",  # Optional. Additional, verbose
                                  details about the error to assist in debugging the indexer. This may
                                  not be always available.
                                "documentationLink": "str",  # Optional. A link to a
                                  troubleshooting guide for these classes of errors. This may not be
                                  always available.
                                "key": "str",  # Optional. The key of the item for
                                  which indexing failed.
                                "name": "str"  # Optional. The name of the source at
                                  which the error originated. For example, this could refer to a
                                  particular skill in the attached skillset. This may not be always
                                  available.
                            }
                        ],
                        "itemsFailed": 0,  # The number of items that failed to be indexed
                          during this indexer execution. Required.
                        "itemsProcessed": 0,  # The number of items that were processed
                          during this indexer execution. This includes both successfully processed
                          items and items where indexing was attempted but failed. Required.
                        "status": "str",  # The outcome of this indexer execution. Required.
                          Known values are: "transientFailure", "success", "inProgress", and "reset".
                        "warnings": [
                            {
                                "message": "str",  # The message describing the
                                  warning that occurred while processing the item. Required.
                                "details": "str",  # Optional. Additional, verbose
                                  details about the warning to assist in debugging the indexer. This
                                  may not be always available.
                                "documentationLink": "str",  # Optional. A link to a
                                  troubleshooting guide for these classes of warnings. This may not be
                                  always available.
                                "key": "str",  # Optional. The key of the item which
                                  generated a warning.
                                "name": "str"  # Optional. The name of the source at
                                  which the warning originated. For example, this could refer to a
                                  particular skill in the attached skillset. This may not be always
                                  available.
                            }
                        ],
                        "currentState": {
                            "allDocsFinalChangeTrackingState": "str",  # Optional. Change
                              tracking state value when indexing finishes on all documents in the
                              datasource.
                            "allDocsInitialChangeTrackingState": "str",  # Optional.
                              Change tracking state used when indexing starts on all documents in the
                              datasource.
                            "mode": "str",  # Optional. The mode the indexer is running
                              in. Known values are: "indexingAllDocs" and "indexingResetDocs".
                            "resetDatasourceDocumentIds": [
                                "str"  # Optional. The list of datasource document
                                  ids that have been reset. The datasource document id is the unique
                                  identifier for the data in the datasource. The indexer will
                                  prioritize selectively re-ingesting these ids.
                            ],
                            "resetDocsFinalChangeTrackingState": "str",  # Optional.
                              Change tracking state value when indexing finishes on select, reset
                              documents in the datasource.
                            "resetDocsInitialChangeTrackingState": "str",  # Optional.
                              Change tracking state used when indexing starts on select, reset
                              documents in the datasource.
                            "resetDocumentKeys": [
                                "str"  # Optional. The list of document keys that
                                  have been reset. The document key is the document's unique identifier
                                  for the data in the search index. The indexer will prioritize
                                  selectively re-ingesting these keys.
                            ]
                        },
                        "endTime": "2020-02-20 00:00:00",  # Optional. The end time of this
                          indexer execution, if the execution has already completed.
                        "errorMessage": "str",  # Optional. The error message indicating the
                          top-level error, if any.
                        "finalTrackingState": "str",  # Optional. Change tracking state with
                          which an indexer execution finished.
                        "initialTrackingState": "str",  # Optional. Change tracking state
                          with which an indexer execution started.
                        "startTime": "2020-02-20 00:00:00",  # Optional. The start time of
                          this indexer execution.
                        "statusDetail": "str"  # Optional. The outcome of this indexer
                          execution. "resetDocs"
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_indexers_get_status_request(
            indexer_name=indexer_name,
            x_ms_client_request_id=x_ms_client_request_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class SkillsetsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~search_service_client.aio.SearchServiceClient`'s
        :attr:`skillsets` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def create_or_update(
        self,
        skillset_name: str,
        skillset: JSON,
        *,
        prefer: str,
        x_ms_client_request_id: Optional[str] = None,
        if_match: Optional[str] = None,
        if_none_match: Optional[str] = None,
        skip_indexer_reset_requirement_for_cache: Optional[bool] = None,
        disable_cache_reprocessing_change_detection: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new skillset in a search service or updates the skillset if it already exists.

        :param skillset_name: The name of the skillset to create or update. Required.
        :type skillset_name: str
        :param skillset: The skillset containing one or more skills to create or update in a search
         service. Required.
        :type skillset: JSON
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword if_match: Defines the If-Match condition. The operation will be performed only if the
         ETag on the server matches this value. Default value is None.
        :paramtype if_match: str
        :keyword if_none_match: Defines the If-None-Match condition. The operation will be performed
         only if the ETag on the server does not match this value. Default value is None.
        :paramtype if_none_match: str
        :keyword skip_indexer_reset_requirement_for_cache: Ignores cache reset requirements. Default
         value is None.
        :paramtype skip_indexer_reset_requirement_for_cache: bool
        :keyword disable_cache_reprocessing_change_detection: Disables cache reprocessing change
         detection. Default value is None.
        :paramtype disable_cache_reprocessing_change_detection: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the cognitive service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the cognitive service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the cognitive service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # JSON input template you can fill out and use as your body input.
                skillset = {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the cognitive service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the cognitive service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the cognitive service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the cognitive service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the cognitive service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the cognitive service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # response body for status code(s): 200, 201
                response == {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }
        """

    @overload
    async def create_or_update(
        self,
        skillset_name: str,
        skillset: IO,
        *,
        prefer: str,
        x_ms_client_request_id: Optional[str] = None,
        if_match: Optional[str] = None,
        if_none_match: Optional[str] = None,
        skip_indexer_reset_requirement_for_cache: Optional[bool] = None,
        disable_cache_reprocessing_change_detection: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new skillset in a search service or updates the skillset if it already exists.

        :param skillset_name: The name of the skillset to create or update. Required.
        :type skillset_name: str
        :param skillset: The skillset containing one or more skills to create or update in a search
         service. Required.
        :type skillset: IO
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword if_match: Defines the If-Match condition. The operation will be performed only if the
         ETag on the server matches this value. Default value is None.
        :paramtype if_match: str
        :keyword if_none_match: Defines the If-None-Match condition. The operation will be performed
         only if the ETag on the server does not match this value. Default value is None.
        :paramtype if_none_match: str
        :keyword skip_indexer_reset_requirement_for_cache: Ignores cache reset requirements. Default
         value is None.
        :paramtype skip_indexer_reset_requirement_for_cache: bool
        :keyword disable_cache_reprocessing_change_detection: Disables cache reprocessing change
         detection. Default value is None.
        :paramtype disable_cache_reprocessing_change_detection: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the cognitive service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the cognitive service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the cognitive service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the cognitive service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the cognitive service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the cognitive service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # response body for status code(s): 200, 201
                response == {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }
        """

    @distributed_trace_async
    async def create_or_update(
        self,
        skillset_name: str,
        skillset: Union[JSON, IO],
        *,
        prefer: str,
        x_ms_client_request_id: Optional[str] = None,
        if_match: Optional[str] = None,
        if_none_match: Optional[str] = None,
        skip_indexer_reset_requirement_for_cache: Optional[bool] = None,
        disable_cache_reprocessing_change_detection: Optional[bool] = None,
        **kwargs: Any
    ) -> JSON:
        """Creates a new skillset in a search service or updates the skillset if it already exists.

        :param skillset_name: The name of the skillset to create or update. Required.
        :type skillset_name: str
        :param skillset: The skillset containing one or more skills to create or update in a search
         service. Is either a model type or a IO type. Required.
        :type skillset: JSON or IO
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword if_match: Defines the If-Match condition. The operation will be performed only if the
         ETag on the server matches this value. Default value is None.
        :paramtype if_match: str
        :keyword if_none_match: Defines the If-None-Match condition. The operation will be performed
         only if the ETag on the server does not match this value. Default value is None.
        :paramtype if_none_match: str
        :keyword skip_indexer_reset_requirement_for_cache: Ignores cache reset requirements. Default
         value is None.
        :paramtype skip_indexer_reset_requirement_for_cache: bool
        :keyword disable_cache_reprocessing_change_detection: Disables cache reprocessing change
         detection. Default value is None.
        :paramtype disable_cache_reprocessing_change_detection: bool
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the cognitive service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the cognitive service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the cognitive service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the cognitive service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the cognitive service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the cognitive service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # response body for status code(s): 200, 201
                response == {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(skillset, (IO, bytes)):
            _content = skillset
        else:
            _json = skillset

        request = build_skillsets_create_or_update_request(
            skillset_name=skillset_name,
            prefer=prefer,
            x_ms_client_request_id=x_ms_client_request_id,
            if_match=if_match,
            if_none_match=if_none_match,
            skip_indexer_reset_requirement_for_cache=skip_indexer_reset_requirement_for_cache,
            disable_cache_reprocessing_change_detection=disable_cache_reprocessing_change_detection,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def delete(  # pylint: disable=inconsistent-return-statements
        self,
        skillset_name: str,
        *,
        x_ms_client_request_id: Optional[str] = None,
        if_match: Optional[str] = None,
        if_none_match: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """Deletes a skillset in a search service.

        :param skillset_name: The name of the skillset to delete. Required.
        :type skillset_name: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword if_match: Defines the If-Match condition. The operation will be performed only if the
         ETag on the server matches this value. Default value is None.
        :paramtype if_match: str
        :keyword if_none_match: Defines the If-None-Match condition. The operation will be performed
         only if the ETag on the server does not match this value. Default value is None.
        :paramtype if_none_match: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_skillsets_delete_request(
            skillset_name=skillset_name,
            x_ms_client_request_id=x_ms_client_request_id,
            if_match=if_match,
            if_none_match=if_none_match,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get(self, skillset_name: str, *, x_ms_client_request_id: Optional[str] = None, **kwargs: Any) -> JSON:
        """Retrieves a skillset in a search service.

        :param skillset_name: The name of the skillset to retrieve. Required.
        :type skillset_name: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the cognitive service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the cognitive service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the cognitive service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # response body for status code(s): 200
                response == {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_skillsets_get_request(
            skillset_name=skillset_name,
            x_ms_client_request_id=x_ms_client_request_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def list(
        self, *, select: Optional[str] = None, x_ms_client_request_id: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """List all skillsets in a search service.

        :keyword select: Selects which top-level properties of the skillsets to retrieve. Specified as
         a comma-separated list of JSON property names, or '*' for all properties. The default is all
         properties. Default value is None.
        :paramtype select: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "name": "str",  # The name of the skillset. Required.
                            "skills": [
                                search_indexer_skill
                            ],
                            "@odata.etag": "str",  # Optional. The ETag of the skillset.
                            "cognitiveServices": cognitive_services_account,
                            "description": "str",  # Optional. The description of the
                              skillset.
                            "encryptionKey": {
                                "keyVaultKeyName": "str",  # The name of your Azure
                                  Key Vault key to be used to encrypt your data at rest. Required.
                                "keyVaultKeyVersion": "str",  # The version of your
                                  Azure Key Vault key to be used to encrypt your data at rest.
                                  Required.
                                "keyVaultUri": "str",  # The URI of your Azure Key
                                  Vault, also referred to as DNS name, that contains the key to be used
                                  to encrypt your data at rest. An example URI might be
                                  https://my-keyvault-name.vault.azure.net. Required.
                                "accessCredentials": {
                                    "applicationId": "str",  # An AAD Application
                                      ID that was granted the required access permissions to the Azure
                                      Key Vault that is to be used when encrypting your data at rest.
                                      The Application ID should not be confused with the Object ID for
                                      your AAD Application. Required.
                                    "applicationSecret": "str"  # Optional. The
                                      authentication key of the specified AAD application.
                                },
                                "identity": search_indexer_data_identity
                            },
                            "knowledgeStore": {
                                "projections": [
                                    {
                                        "files": [
                                            {
                                                "storageContainer":
                                                  "str",  # Blob container to store projections in.
                                                  Required.
                                                "generatedKeyName":
                                                  "str",  # Optional. Name of generated key to store
                                                  projection under.
                                                "inputs": [
                                                    {
                "name": "str",  # The name of the input.
                                                          Required.
                "inputs": [
                ...
                                                        ],
                "source": "str",  # Optional. The source of
                                                          the input.
                "sourceContext": "str"  # Optional. The
                                                          source context used for selecting recursive
                                                          inputs.
                                                    }
                                                ],
                                                "referenceKeyName":
                                                  "str",  # Optional. Name of reference key to
                                                  different projection.
                                                "source": "str",  #
                                                  Optional. Source data to project.
                                                "sourceContext":
                                                  "str"  # Optional. Source context for complex
                                                  projections.
                                            }
                                        ],
                                        "objects": [
                                            {
                                                "storageContainer":
                                                  "str",  # Blob container to store projections in.
                                                  Required.
                                                "generatedKeyName":
                                                  "str",  # Optional. Name of generated key to store
                                                  projection under.
                                                "inputs": [
                                                    {
                "name": "str",  # The name of the input.
                                                          Required.
                "inputs": [
                ...
                                                        ],
                "source": "str",  # Optional. The source of
                                                          the input.
                "sourceContext": "str"  # Optional. The
                                                          source context used for selecting recursive
                                                          inputs.
                                                    }
                                                ],
                                                "referenceKeyName":
                                                  "str",  # Optional. Name of reference key to
                                                  different projection.
                                                "source": "str",  #
                                                  Optional. Source data to project.
                                                "sourceContext":
                                                  "str"  # Optional. Source context for complex
                                                  projections.
                                            }
                                        ],
                                        "tables": [
                                            {
                                                "tableName": "str",
                                                  # Name of the Azure table to store projected data in.
                                                  Required.
                                                "generatedKeyName":
                                                  "str",  # Optional. Name of generated key to store
                                                  projection under.
                                                "inputs": [
                                                    {
                "name": "str",  # The name of the input.
                                                          Required.
                "inputs": [
                ...
                                                        ],
                "source": "str",  # Optional. The source of
                                                          the input.
                "sourceContext": "str"  # Optional. The
                                                          source context used for selecting recursive
                                                          inputs.
                                                    }
                                                ],
                                                "referenceKeyName":
                                                  "str",  # Optional. Name of reference key to
                                                  different projection.
                                                "source": "str",  #
                                                  Optional. Source data to project.
                                                "sourceContext":
                                                  "str"  # Optional. Source context for complex
                                                  projections.
                                            }
                                        ]
                                    }
                                ],
                                "storageConnectionString": "str"  # The connection
                                  string to the storage account projections will be stored in.
                                  Required.
                            }
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_skillsets_list_request(
            select=select,
            x_ms_client_request_id=x_ms_client_request_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def create(
        self,
        skillset: JSON,
        *,
        x_ms_client_request_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new skillset in a search service.

        :param skillset: The skillset containing one or more skills to create in a search service.
         Required.
        :type skillset: JSON
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the cognitive service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the cognitive service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the cognitive service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # JSON input template you can fill out and use as your body input.
                skillset = {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the cognitive service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the cognitive service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the cognitive service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # response body for status code(s): 201
                response == {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }
        """

    @overload
    async def create(
        self,
        skillset: IO,
        *,
        x_ms_client_request_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new skillset in a search service.

        :param skillset: The skillset containing one or more skills to create in a search service.
         Required.
        :type skillset: IO
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the cognitive service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the cognitive service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the cognitive service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # response body for status code(s): 201
                response == {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }
        """

    @distributed_trace_async
    async def create(
        self, skillset: Union[JSON, IO], *, x_ms_client_request_id: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Creates a new skillset in a search service.

        :param skillset: The skillset containing one or more skills to create in a search service. Is
         either a model type or a IO type. Required.
        :type skillset: JSON or IO
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.CognitiveServicesByKey":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.CognitiveServicesByKey"
                    "key": "str",  # The key used to provision the cognitive service resource
                      attached to a skillset. Required.
                    "description": "str"  # Optional. Description of the cognitive service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DefaultCognitiveServices":
                cognitive_services_account = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DefaultCognitiveServices"
                    "description": "str"  # Optional. Description of the cognitive service
                      resource attached to a skillset.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # response body for status code(s): 201
                response == {
                    "name": "str",  # The name of the skillset. Required.
                    "skills": [
                        search_indexer_skill
                    ],
                    "@odata.etag": "str",  # Optional. The ETag of the skillset.
                    "cognitiveServices": cognitive_services_account,
                    "description": "str",  # Optional. The description of the skillset.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "knowledgeStore": {
                        "projections": [
                            {
                                "files": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "objects": [
                                    {
                                        "storageContainer": "str",  # Blob
                                          container to store projections in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ],
                                "tables": [
                                    {
                                        "tableName": "str",  # Name of the
                                          Azure table to store projected data in. Required.
                                        "generatedKeyName": "str",  #
                                          Optional. Name of generated key to store projection under.
                                        "inputs": [
                                            {
                                                "name": "str",  # The
                                                  name of the input. Required.
                                                "inputs": [
                                                    ...
                                                ],
                                                "source": "str",  #
                                                  Optional. The source of the input.
                                                "sourceContext":
                                                  "str"  # Optional. The source context used for
                                                  selecting recursive inputs.
                                            }
                                        ],
                                        "referenceKeyName": "str",  #
                                          Optional. Name of reference key to different projection.
                                        "source": "str",  # Optional. Source
                                          data to project.
                                        "sourceContext": "str"  # Optional.
                                          Source context for complex projections.
                                    }
                                ]
                            }
                        ],
                        "storageConnectionString": "str"  # The connection string to the
                          storage account projections will be stored in. Required.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(skillset, (IO, bytes)):
            _content = skillset
        else:
            _json = skillset

        request = build_skillsets_create_request(
            x_ms_client_request_id=x_ms_client_request_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def reset_skills(  # pylint: disable=inconsistent-return-statements
        self,
        skillset_name: str,
        skill_names: JSON,
        *,
        x_ms_client_request_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Reset an existing skillset in a search service.

        :param skillset_name: The name of the skillset to reset. Required.
        :type skillset_name: str
        :param skill_names: The names of skills to reset. Required.
        :type skill_names: JSON
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                skill_names = {
                    "skillNames": [
                        "str"  # Optional. the names of skills to be reset.
                    ]
                }
        """

    @overload
    async def reset_skills(  # pylint: disable=inconsistent-return-statements
        self,
        skillset_name: str,
        skill_names: IO,
        *,
        x_ms_client_request_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Reset an existing skillset in a search service.

        :param skillset_name: The name of the skillset to reset. Required.
        :type skillset_name: str
        :param skill_names: The names of skills to reset. Required.
        :type skill_names: IO
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def reset_skills(  # pylint: disable=inconsistent-return-statements
        self,
        skillset_name: str,
        skill_names: Union[JSON, IO],
        *,
        x_ms_client_request_id: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """Reset an existing skillset in a search service.

        :param skillset_name: The name of the skillset to reset. Required.
        :type skillset_name: str
        :param skill_names: The names of skills to reset. Is either a model type or a IO type.
         Required.
        :type skill_names: JSON or IO
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(skill_names, (IO, bytes)):
            _content = skill_names
        else:
            _json = skill_names

        request = build_skillsets_reset_skills_request(
            skillset_name=skillset_name,
            x_ms_client_request_id=x_ms_client_request_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})


class SynonymMapsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~search_service_client.aio.SearchServiceClient`'s
        :attr:`synonym_maps` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def create_or_update(
        self,
        synonym_map_name: str,
        synonym_map: JSON,
        *,
        prefer: str,
        x_ms_client_request_id: Optional[str] = None,
        if_match: Optional[str] = None,
        if_none_match: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new synonym map or updates a synonym map if it already exists.

        :param synonym_map_name: The name of the synonym map to create or update. Required.
        :type synonym_map_name: str
        :param synonym_map: The definition of the synonym map to create or update. Required.
        :type synonym_map: JSON
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword if_match: Defines the If-Match condition. The operation will be performed only if the
         ETag on the server matches this value. Default value is None.
        :paramtype if_match: str
        :keyword if_none_match: Defines the If-None-Match condition. The operation will be performed
         only if the ETag on the server does not match this value. Default value is None.
        :paramtype if_none_match: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # JSON input template you can fill out and use as your body input.
                synonym_map = {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    }
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # response body for status code(s): 200, 201
                response == {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    }
                }
        """

    @overload
    async def create_or_update(
        self,
        synonym_map_name: str,
        synonym_map: IO,
        *,
        prefer: str,
        x_ms_client_request_id: Optional[str] = None,
        if_match: Optional[str] = None,
        if_none_match: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new synonym map or updates a synonym map if it already exists.

        :param synonym_map_name: The name of the synonym map to create or update. Required.
        :type synonym_map_name: str
        :param synonym_map: The definition of the synonym map to create or update. Required.
        :type synonym_map: IO
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword if_match: Defines the If-Match condition. The operation will be performed only if the
         ETag on the server matches this value. Default value is None.
        :paramtype if_match: str
        :keyword if_none_match: Defines the If-None-Match condition. The operation will be performed
         only if the ETag on the server does not match this value. Default value is None.
        :paramtype if_none_match: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # response body for status code(s): 200, 201
                response == {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    }
                }
        """

    @distributed_trace_async
    async def create_or_update(
        self,
        synonym_map_name: str,
        synonym_map: Union[JSON, IO],
        *,
        prefer: str,
        x_ms_client_request_id: Optional[str] = None,
        if_match: Optional[str] = None,
        if_none_match: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """Creates a new synonym map or updates a synonym map if it already exists.

        :param synonym_map_name: The name of the synonym map to create or update. Required.
        :type synonym_map_name: str
        :param synonym_map: The definition of the synonym map to create or update. Is either a model
         type or a IO type. Required.
        :type synonym_map: JSON or IO
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword if_match: Defines the If-Match condition. The operation will be performed only if the
         ETag on the server matches this value. Default value is None.
        :paramtype if_match: str
        :keyword if_none_match: Defines the If-None-Match condition. The operation will be performed
         only if the ETag on the server does not match this value. Default value is None.
        :paramtype if_none_match: str
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # response body for status code(s): 200, 201
                response == {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(synonym_map, (IO, bytes)):
            _content = synonym_map
        else:
            _json = synonym_map

        request = build_synonym_maps_create_or_update_request(
            synonym_map_name=synonym_map_name,
            prefer=prefer,
            x_ms_client_request_id=x_ms_client_request_id,
            if_match=if_match,
            if_none_match=if_none_match,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def delete(  # pylint: disable=inconsistent-return-statements
        self,
        synonym_map_name: str,
        *,
        x_ms_client_request_id: Optional[str] = None,
        if_match: Optional[str] = None,
        if_none_match: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """Deletes a synonym map.

        :param synonym_map_name: The name of the synonym map to delete. Required.
        :type synonym_map_name: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword if_match: Defines the If-Match condition. The operation will be performed only if the
         ETag on the server matches this value. Default value is None.
        :paramtype if_match: str
        :keyword if_none_match: Defines the If-None-Match condition. The operation will be performed
         only if the ETag on the server does not match this value. Default value is None.
        :paramtype if_none_match: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_synonym_maps_delete_request(
            synonym_map_name=synonym_map_name,
            x_ms_client_request_id=x_ms_client_request_id,
            if_match=if_match,
            if_none_match=if_none_match,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get(self, synonym_map_name: str, *, x_ms_client_request_id: Optional[str] = None, **kwargs: Any) -> JSON:
        """Retrieves a synonym map definition.

        :param synonym_map_name: The name of the synonym map to retrieve. Required.
        :type synonym_map_name: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # response body for status code(s): 200
                response == {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_synonym_maps_get_request(
            synonym_map_name=synonym_map_name,
            x_ms_client_request_id=x_ms_client_request_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def list(
        self, *, select: Optional[str] = None, x_ms_client_request_id: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Lists all synonym maps available for a search service.

        :keyword select: Selects which top-level properties of the synonym maps to retrieve. Specified
         as a comma-separated list of JSON property names, or '*' for all properties. The default is all
         properties. Default value is None.
        :paramtype select: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "format": "solr",  # Default value is "solr". The format of
                              the synonym map. Only the 'solr' format is currently supported. Required.
                            "name": "str",  # The name of the synonym map. Required.
                            "synonyms": "str",  # A series of synonym rules in the
                              specified synonym map format. The rules must be separated by newlines.
                              Required.
                            "@odata.etag": "str",  # Optional. The ETag of the synonym
                              map.
                            "encryptionKey": {
                                "keyVaultKeyName": "str",  # The name of your Azure
                                  Key Vault key to be used to encrypt your data at rest. Required.
                                "keyVaultKeyVersion": "str",  # The version of your
                                  Azure Key Vault key to be used to encrypt your data at rest.
                                  Required.
                                "keyVaultUri": "str",  # The URI of your Azure Key
                                  Vault, also referred to as DNS name, that contains the key to be used
                                  to encrypt your data at rest. An example URI might be
                                  https://my-keyvault-name.vault.azure.net. Required.
                                "accessCredentials": {
                                    "applicationId": "str",  # An AAD Application
                                      ID that was granted the required access permissions to the Azure
                                      Key Vault that is to be used when encrypting your data at rest.
                                      The Application ID should not be confused with the Object ID for
                                      your AAD Application. Required.
                                    "applicationSecret": "str"  # Optional. The
                                      authentication key of the specified AAD application.
                                },
                                "identity": search_indexer_data_identity
                            }
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_synonym_maps_list_request(
            select=select,
            x_ms_client_request_id=x_ms_client_request_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def create(
        self,
        synonym_map: JSON,
        *,
        x_ms_client_request_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new synonym map.

        :param synonym_map: The definition of the synonym map to create. Required.
        :type synonym_map: JSON
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # JSON input template you can fill out and use as your body input.
                synonym_map = {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    }
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # response body for status code(s): 201
                response == {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    }
                }
        """

    @overload
    async def create(
        self,
        synonym_map: IO,
        *,
        x_ms_client_request_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new synonym map.

        :param synonym_map: The definition of the synonym map to create. Required.
        :type synonym_map: IO
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # response body for status code(s): 201
                response == {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    }
                }
        """

    @distributed_trace_async
    async def create(
        self, synonym_map: Union[JSON, IO], *, x_ms_client_request_id: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Creates a new synonym map.

        :param synonym_map: The definition of the synonym map to create. Is either a model type or a IO
         type. Required.
        :type synonym_map: JSON or IO
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # response body for status code(s): 201
                response == {
                    "format": "solr",  # Default value is "solr". The format of the synonym map.
                      Only the 'solr' format is currently supported. Required.
                    "name": "str",  # The name of the synonym map. Required.
                    "synonyms": "str",  # A series of synonym rules in the specified synonym map
                      format. The rules must be separated by newlines. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the synonym map.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(synonym_map, (IO, bytes)):
            _content = synonym_map
        else:
            _json = synonym_map

        request = build_synonym_maps_create_request(
            x_ms_client_request_id=x_ms_client_request_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class IndexesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~search_service_client.aio.SearchServiceClient`'s
        :attr:`indexes` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def create(
        self,
        index: JSON,
        *,
        x_ms_client_request_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new search index.

        :param index: The definition of the index to create. Required.
        :type index: JSON
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # JSON input template you can fill out and use as your body input.
                index = {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint", and
                              "Edm.ComplexType".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "normalizer": "str",  # Optional. The name of the normalizer
                              to use for the field. This option can be used only with fields with
                              filterable, sortable, or facetable enabled. Once the normalizer is
                              chosen, it cannot be changed for the field. Must be null for complex
                              fields. Known values are: "asciifolding", "elision", "lowercase",
                              "standard", and "uppercase".
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields and null for complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index since Azure Cognitive
                              Search will store an additional tokenized version of the field value for
                              full-text searches. If you want to save space in your index and you don't
                              need a field to be included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default
                              Azure Cognitive Search sorts results by score, but in many experiences
                              users will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ]
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "normalizers": [
                        lexical_normalizer
                    ],
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  #
                                              Optional. Defines the content fields to be used for
                                              semantic ranking, captions, highlights, and answers. For
                                              the best result, the selected fields should contain text
                                              in natural language form. The order of the fields in the
                                              array represents their priority. Fields with lower
                                              priority may get truncated if the content is long.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  #
                                              Optional. Defines the keyword fields to be used for
                                              semantic ranking, captions, highlights, and answers. For
                                              the best result, the selected fields should contain a
                                              list of keywords. The order of the fields in the array
                                              represents their priority. Fields with lower priority may
                                              get truncated if the content is long.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # Optional.
                                          Defines the title field to be used for semantic ranking,
                                          captions, highlights, and answers. If you don't have a title
                                          field in your index, leave this blank.
                                    }
                                }
                            }
                        ]
                    },
                    "similarity": similarity,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ]
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # response body for status code(s): 201
                response == {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint", and
                              "Edm.ComplexType".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "normalizer": "str",  # Optional. The name of the normalizer
                              to use for the field. This option can be used only with fields with
                              filterable, sortable, or facetable enabled. Once the normalizer is
                              chosen, it cannot be changed for the field. Must be null for complex
                              fields. Known values are: "asciifolding", "elision", "lowercase",
                              "standard", and "uppercase".
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields and null for complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index since Azure Cognitive
                              Search will store an additional tokenized version of the field value for
                              full-text searches. If you want to save space in your index and you don't
                              need a field to be included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default
                              Azure Cognitive Search sorts results by score, but in many experiences
                              users will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ]
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "normalizers": [
                        lexical_normalizer
                    ],
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  #
                                              Optional. Defines the content fields to be used for
                                              semantic ranking, captions, highlights, and answers. For
                                              the best result, the selected fields should contain text
                                              in natural language form. The order of the fields in the
                                              array represents their priority. Fields with lower
                                              priority may get truncated if the content is long.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  #
                                              Optional. Defines the keyword fields to be used for
                                              semantic ranking, captions, highlights, and answers. For
                                              the best result, the selected fields should contain a
                                              list of keywords. The order of the fields in the array
                                              represents their priority. Fields with lower priority may
                                              get truncated if the content is long.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # Optional.
                                          Defines the title field to be used for semantic ranking,
                                          captions, highlights, and answers. If you don't have a title
                                          field in your index, leave this blank.
                                    }
                                }
                            }
                        ]
                    },
                    "similarity": similarity,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ]
                }
        """

    @overload
    async def create(
        self,
        index: IO,
        *,
        x_ms_client_request_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new search index.

        :param index: The definition of the index to create. Required.
        :type index: IO
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # response body for status code(s): 201
                response == {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint", and
                              "Edm.ComplexType".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "normalizer": "str",  # Optional. The name of the normalizer
                              to use for the field. This option can be used only with fields with
                              filterable, sortable, or facetable enabled. Once the normalizer is
                              chosen, it cannot be changed for the field. Must be null for complex
                              fields. Known values are: "asciifolding", "elision", "lowercase",
                              "standard", and "uppercase".
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields and null for complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index since Azure Cognitive
                              Search will store an additional tokenized version of the field value for
                              full-text searches. If you want to save space in your index and you don't
                              need a field to be included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default
                              Azure Cognitive Search sorts results by score, but in many experiences
                              users will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ]
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "normalizers": [
                        lexical_normalizer
                    ],
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  #
                                              Optional. Defines the content fields to be used for
                                              semantic ranking, captions, highlights, and answers. For
                                              the best result, the selected fields should contain text
                                              in natural language form. The order of the fields in the
                                              array represents their priority. Fields with lower
                                              priority may get truncated if the content is long.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  #
                                              Optional. Defines the keyword fields to be used for
                                              semantic ranking, captions, highlights, and answers. For
                                              the best result, the selected fields should contain a
                                              list of keywords. The order of the fields in the array
                                              represents their priority. Fields with lower priority may
                                              get truncated if the content is long.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # Optional.
                                          Defines the title field to be used for semantic ranking,
                                          captions, highlights, and answers. If you don't have a title
                                          field in your index, leave this blank.
                                    }
                                }
                            }
                        ]
                    },
                    "similarity": similarity,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ]
                }
        """

    @distributed_trace_async
    async def create(
        self, index: Union[JSON, IO], *, x_ms_client_request_id: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Creates a new search index.

        :param index: The definition of the index to create. Is either a model type or a IO type.
         Required.
        :type index: JSON or IO
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # response body for status code(s): 201
                response == {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint", and
                              "Edm.ComplexType".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "normalizer": "str",  # Optional. The name of the normalizer
                              to use for the field. This option can be used only with fields with
                              filterable, sortable, or facetable enabled. Once the normalizer is
                              chosen, it cannot be changed for the field. Must be null for complex
                              fields. Known values are: "asciifolding", "elision", "lowercase",
                              "standard", and "uppercase".
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields and null for complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index since Azure Cognitive
                              Search will store an additional tokenized version of the field value for
                              full-text searches. If you want to save space in your index and you don't
                              need a field to be included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default
                              Azure Cognitive Search sorts results by score, but in many experiences
                              users will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ]
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "normalizers": [
                        lexical_normalizer
                    ],
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  #
                                              Optional. Defines the content fields to be used for
                                              semantic ranking, captions, highlights, and answers. For
                                              the best result, the selected fields should contain text
                                              in natural language form. The order of the fields in the
                                              array represents their priority. Fields with lower
                                              priority may get truncated if the content is long.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  #
                                              Optional. Defines the keyword fields to be used for
                                              semantic ranking, captions, highlights, and answers. For
                                              the best result, the selected fields should contain a
                                              list of keywords. The order of the fields in the array
                                              represents their priority. Fields with lower priority may
                                              get truncated if the content is long.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # Optional.
                                          Defines the title field to be used for semantic ranking,
                                          captions, highlights, and answers. If you don't have a title
                                          field in your index, leave this blank.
                                    }
                                }
                            }
                        ]
                    },
                    "similarity": similarity,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(index, (IO, bytes)):
            _content = index
        else:
            _json = index

        request = build_indexes_create_request(
            x_ms_client_request_id=x_ms_client_request_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def list(
        self, *, select: Optional[str] = None, x_ms_client_request_id: Optional[str] = None, **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """Lists all indexes available for a search service.

        :keyword select: Selects which top-level properties of the index definitions to retrieve.
         Specified as a comma-separated list of JSON property names, or '*' for all properties. The
         default is all properties. Default value is None.
        :paramtype select: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # response body for status code(s): 200
                response == {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint", and
                              "Edm.ComplexType".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "normalizer": "str",  # Optional. The name of the normalizer
                              to use for the field. This option can be used only with fields with
                              filterable, sortable, or facetable enabled. Once the normalizer is
                              chosen, it cannot be changed for the field. Must be null for complex
                              fields. Known values are: "asciifolding", "elision", "lowercase",
                              "standard", and "uppercase".
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields and null for complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index since Azure Cognitive
                              Search will store an additional tokenized version of the field value for
                              full-text searches. If you want to save space in your index and you don't
                              need a field to be included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default
                              Azure Cognitive Search sorts results by score, but in many experiences
                              users will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ]
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "normalizers": [
                        lexical_normalizer
                    ],
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  #
                                              Optional. Defines the content fields to be used for
                                              semantic ranking, captions, highlights, and answers. For
                                              the best result, the selected fields should contain text
                                              in natural language form. The order of the fields in the
                                              array represents their priority. Fields with lower
                                              priority may get truncated if the content is long.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  #
                                              Optional. Defines the keyword fields to be used for
                                              semantic ranking, captions, highlights, and answers. For
                                              the best result, the selected fields should contain a
                                              list of keywords. The order of the fields in the array
                                              represents their priority. Fields with lower priority may
                                              get truncated if the content is long.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # Optional.
                                          Defines the title field to be used for semantic ranking,
                                          captions, highlights, and answers. If you don't have a title
                                          field in your index, leave this blank.
                                    }
                                }
                            }
                        ]
                    },
                    "similarity": similarity,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ]
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_indexes_list_request(
                    select=select,
                    x_ms_client_request_id=x_ms_client_request_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @overload
    async def create_or_update(
        self,
        index_name: str,
        index: JSON,
        *,
        prefer: str,
        allow_index_downtime: Optional[bool] = None,
        x_ms_client_request_id: Optional[str] = None,
        if_match: Optional[str] = None,
        if_none_match: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new search index or updates an index if it already exists.

        :param index_name: The definition of the index to create or update. Required.
        :type index_name: str
        :param index: The definition of the index to create or update. Required.
        :type index: JSON
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str
        :keyword allow_index_downtime: Allows new analyzers, tokenizers, token filters, or char filters
         to be added to an index by taking the index offline for at least a few seconds. This
         temporarily causes indexing and query requests to fail. Performance and write availability of
         the index can be impaired for several minutes after the index is updated, or longer for very
         large indexes. Default value is None.
        :paramtype allow_index_downtime: bool
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword if_match: Defines the If-Match condition. The operation will be performed only if the
         ETag on the server matches this value. Default value is None.
        :paramtype if_match: str
        :keyword if_none_match: Defines the If-None-Match condition. The operation will be performed
         only if the ETag on the server does not match this value. Default value is None.
        :paramtype if_none_match: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # JSON input template you can fill out and use as your body input.
                index = {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint", and
                              "Edm.ComplexType".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "normalizer": "str",  # Optional. The name of the normalizer
                              to use for the field. This option can be used only with fields with
                              filterable, sortable, or facetable enabled. Once the normalizer is
                              chosen, it cannot be changed for the field. Must be null for complex
                              fields. Known values are: "asciifolding", "elision", "lowercase",
                              "standard", and "uppercase".
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields and null for complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index since Azure Cognitive
                              Search will store an additional tokenized version of the field value for
                              full-text searches. If you want to save space in your index and you don't
                              need a field to be included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default
                              Azure Cognitive Search sorts results by score, but in many experiences
                              users will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ]
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "normalizers": [
                        lexical_normalizer
                    ],
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  #
                                              Optional. Defines the content fields to be used for
                                              semantic ranking, captions, highlights, and answers. For
                                              the best result, the selected fields should contain text
                                              in natural language form. The order of the fields in the
                                              array represents their priority. Fields with lower
                                              priority may get truncated if the content is long.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  #
                                              Optional. Defines the keyword fields to be used for
                                              semantic ranking, captions, highlights, and answers. For
                                              the best result, the selected fields should contain a
                                              list of keywords. The order of the fields in the array
                                              represents their priority. Fields with lower priority may
                                              get truncated if the content is long.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # Optional.
                                          Defines the title field to be used for semantic ranking,
                                          captions, highlights, and answers. If you don't have a title
                                          field in your index, leave this blank.
                                    }
                                }
                            }
                        ]
                    },
                    "similarity": similarity,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ]
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # response body for status code(s): 200, 201
                response == {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint", and
                              "Edm.ComplexType".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "normalizer": "str",  # Optional. The name of the normalizer
                              to use for the field. This option can be used only with fields with
                              filterable, sortable, or facetable enabled. Once the normalizer is
                              chosen, it cannot be changed for the field. Must be null for complex
                              fields. Known values are: "asciifolding", "elision", "lowercase",
                              "standard", and "uppercase".
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields and null for complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index since Azure Cognitive
                              Search will store an additional tokenized version of the field value for
                              full-text searches. If you want to save space in your index and you don't
                              need a field to be included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default
                              Azure Cognitive Search sorts results by score, but in many experiences
                              users will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ]
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "normalizers": [
                        lexical_normalizer
                    ],
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  #
                                              Optional. Defines the content fields to be used for
                                              semantic ranking, captions, highlights, and answers. For
                                              the best result, the selected fields should contain text
                                              in natural language form. The order of the fields in the
                                              array represents their priority. Fields with lower
                                              priority may get truncated if the content is long.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  #
                                              Optional. Defines the keyword fields to be used for
                                              semantic ranking, captions, highlights, and answers. For
                                              the best result, the selected fields should contain a
                                              list of keywords. The order of the fields in the array
                                              represents their priority. Fields with lower priority may
                                              get truncated if the content is long.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # Optional.
                                          Defines the title field to be used for semantic ranking,
                                          captions, highlights, and answers. If you don't have a title
                                          field in your index, leave this blank.
                                    }
                                }
                            }
                        ]
                    },
                    "similarity": similarity,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ]
                }
        """

    @overload
    async def create_or_update(
        self,
        index_name: str,
        index: IO,
        *,
        prefer: str,
        allow_index_downtime: Optional[bool] = None,
        x_ms_client_request_id: Optional[str] = None,
        if_match: Optional[str] = None,
        if_none_match: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new search index or updates an index if it already exists.

        :param index_name: The definition of the index to create or update. Required.
        :type index_name: str
        :param index: The definition of the index to create or update. Required.
        :type index: IO
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str
        :keyword allow_index_downtime: Allows new analyzers, tokenizers, token filters, or char filters
         to be added to an index by taking the index offline for at least a few seconds. This
         temporarily causes indexing and query requests to fail. Performance and write availability of
         the index can be impaired for several minutes after the index is updated, or longer for very
         large indexes. Default value is None.
        :paramtype allow_index_downtime: bool
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword if_match: Defines the If-Match condition. The operation will be performed only if the
         ETag on the server matches this value. Default value is None.
        :paramtype if_match: str
        :keyword if_none_match: Defines the If-None-Match condition. The operation will be performed
         only if the ETag on the server does not match this value. Default value is None.
        :paramtype if_none_match: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # response body for status code(s): 200, 201
                response == {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint", and
                              "Edm.ComplexType".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "normalizer": "str",  # Optional. The name of the normalizer
                              to use for the field. This option can be used only with fields with
                              filterable, sortable, or facetable enabled. Once the normalizer is
                              chosen, it cannot be changed for the field. Must be null for complex
                              fields. Known values are: "asciifolding", "elision", "lowercase",
                              "standard", and "uppercase".
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields and null for complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index since Azure Cognitive
                              Search will store an additional tokenized version of the field value for
                              full-text searches. If you want to save space in your index and you don't
                              need a field to be included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default
                              Azure Cognitive Search sorts results by score, but in many experiences
                              users will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ]
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "normalizers": [
                        lexical_normalizer
                    ],
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  #
                                              Optional. Defines the content fields to be used for
                                              semantic ranking, captions, highlights, and answers. For
                                              the best result, the selected fields should contain text
                                              in natural language form. The order of the fields in the
                                              array represents their priority. Fields with lower
                                              priority may get truncated if the content is long.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  #
                                              Optional. Defines the keyword fields to be used for
                                              semantic ranking, captions, highlights, and answers. For
                                              the best result, the selected fields should contain a
                                              list of keywords. The order of the fields in the array
                                              represents their priority. Fields with lower priority may
                                              get truncated if the content is long.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # Optional.
                                          Defines the title field to be used for semantic ranking,
                                          captions, highlights, and answers. If you don't have a title
                                          field in your index, leave this blank.
                                    }
                                }
                            }
                        ]
                    },
                    "similarity": similarity,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ]
                }
        """

    @distributed_trace_async
    async def create_or_update(
        self,
        index_name: str,
        index: Union[JSON, IO],
        *,
        prefer: str,
        allow_index_downtime: Optional[bool] = None,
        x_ms_client_request_id: Optional[str] = None,
        if_match: Optional[str] = None,
        if_none_match: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """Creates a new search index or updates an index if it already exists.

        :param index_name: The definition of the index to create or update. Required.
        :type index_name: str
        :param index: The definition of the index to create or update. Is either a model type or a IO
         type. Required.
        :type index: JSON or IO
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str
        :keyword allow_index_downtime: Allows new analyzers, tokenizers, token filters, or char filters
         to be added to an index by taking the index offline for at least a few seconds. This
         temporarily causes indexing and query requests to fail. Performance and write availability of
         the index can be impaired for several minutes after the index is updated, or longer for very
         large indexes. Default value is None.
        :paramtype allow_index_downtime: bool
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword if_match: Defines the If-Match condition. The operation will be performed only if the
         ETag on the server matches this value. Default value is None.
        :paramtype if_match: str
        :keyword if_none_match: Defines the If-None-Match condition. The operation will be performed
         only if the ETag on the server does not match this value. Default value is None.
        :paramtype if_none_match: str
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # response body for status code(s): 200, 201
                response == {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint", and
                              "Edm.ComplexType".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "normalizer": "str",  # Optional. The name of the normalizer
                              to use for the field. This option can be used only with fields with
                              filterable, sortable, or facetable enabled. Once the normalizer is
                              chosen, it cannot be changed for the field. Must be null for complex
                              fields. Known values are: "asciifolding", "elision", "lowercase",
                              "standard", and "uppercase".
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields and null for complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index since Azure Cognitive
                              Search will store an additional tokenized version of the field value for
                              full-text searches. If you want to save space in your index and you don't
                              need a field to be included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default
                              Azure Cognitive Search sorts results by score, but in many experiences
                              users will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ]
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "normalizers": [
                        lexical_normalizer
                    ],
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  #
                                              Optional. Defines the content fields to be used for
                                              semantic ranking, captions, highlights, and answers. For
                                              the best result, the selected fields should contain text
                                              in natural language form. The order of the fields in the
                                              array represents their priority. Fields with lower
                                              priority may get truncated if the content is long.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  #
                                              Optional. Defines the keyword fields to be used for
                                              semantic ranking, captions, highlights, and answers. For
                                              the best result, the selected fields should contain a
                                              list of keywords. The order of the fields in the array
                                              represents their priority. Fields with lower priority may
                                              get truncated if the content is long.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # Optional.
                                          Defines the title field to be used for semantic ranking,
                                          captions, highlights, and answers. If you don't have a title
                                          field in your index, leave this blank.
                                    }
                                }
                            }
                        ]
                    },
                    "similarity": similarity,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(index, (IO, bytes)):
            _content = index
        else:
            _json = index

        request = build_indexes_create_or_update_request(
            index_name=index_name,
            prefer=prefer,
            allow_index_downtime=allow_index_downtime,
            x_ms_client_request_id=x_ms_client_request_id,
            if_match=if_match,
            if_none_match=if_none_match,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def delete(  # pylint: disable=inconsistent-return-statements
        self,
        index_name: str,
        *,
        x_ms_client_request_id: Optional[str] = None,
        if_match: Optional[str] = None,
        if_none_match: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """Deletes a search index and all the documents it contains. This operation is permanent, with no
        recovery option. Make sure you have a master copy of your index definition, data ingestion
        code, and a backup of the primary data source in case you need to re-build the index.

        :param index_name: The name of the index to delete. Required.
        :type index_name: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword if_match: Defines the If-Match condition. The operation will be performed only if the
         ETag on the server matches this value. Default value is None.
        :paramtype if_match: str
        :keyword if_none_match: Defines the If-None-Match condition. The operation will be performed
         only if the ETag on the server does not match this value. Default value is None.
        :paramtype if_none_match: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_indexes_delete_request(
            index_name=index_name,
            x_ms_client_request_id=x_ms_client_request_id,
            if_match=if_match,
            if_none_match=if_none_match,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get(self, index_name: str, *, x_ms_client_request_id: Optional[str] = None, **kwargs: Any) -> JSON:
        """Retrieves an index definition.

        :param index_name: The name of the index to retrieve. Required.
        :type index_name: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "@odata.type":

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataNoneIdentity":
                search_indexer_data_identity = {
                    "@odata.type": "  #Microsoft.Azure.Search.DataNoneIdentity"
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.DataUserAssignedIdentity":
                search_indexer_data_identity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.DataUserAssignedIdentity"
                    "userAssignedIdentity": "str"  # The fully qualified Azure resource Id of a
                      user assigned managed identity typically in the form
                      "/subscriptions/12345678-1234-1234-1234-1234567890ab/resourceGroups/rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId"
                      that should have been assigned to the search service. Required.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.BM25Similarity":
                similarity = {
                    "@odata.type": ",  #Microsoft.Azure.Search.BM25Similarity"
                    "b": 0.0,  # Optional. This property controls how the length of a document
                      affects the relevance score. By default, a value of 0.75 is used. A value of 0.0
                      means no length normalization is applied, while a value of 1.0 means the score is
                      fully normalized by the length of the document.
                    "k1": 0.0  # Optional. This property controls the scaling function between
                      the term frequency of each matching terms and the final relevance score of a
                      document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the
                      score does not scale with an increase in term frequency.
                }

                # JSON input template for discriminator value
                  "#Microsoft.Azure.Search.ClassicSimilarity":
                similarity = {
                    "@odata.type": "  #Microsoft.Azure.Search.ClassicSimilarity"
                }

                # response body for status code(s): 200
                response == {
                    "fields": [
                        {
                            "name": "str",  # The name of the field, which must be unique
                              within the fields collection of the index or parent field. Required.
                            "type": "str",  # The data type of the field. Required. Known
                              values are: "Edm.String", "Edm.Int32", "Edm.Int64", "Edm.Double",
                              "Edm.Boolean", "Edm.DateTimeOffset", "Edm.GeographyPoint", and
                              "Edm.ComplexType".
                            "analyzer": "str",  # Optional. The name of the analyzer to
                              use for the field. This option can be used only with searchable fields
                              and it can't be set together with either searchAnalyzer or indexAnalyzer.
                              Once the analyzer is chosen, it cannot be changed for the field. Must be
                              null for complex fields. Known values are: "ar.microsoft", "ar.lucene",
                              "hy.lucene", "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene",
                              "ca.microsoft", "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene",
                              "zh-Hant.microsoft", "zh-Hant.lucene", "hr.microsoft", "cs.microsoft",
                              "cs.lucene", "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene",
                              "en.microsoft", "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene",
                              "fr.microsoft", "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene",
                              "el.microsoft", "el.lucene", "gu.microsoft", "he.microsoft",
                              "hi.microsoft", "hi.lucene", "hu.microsoft", "hu.lucene", "is.microsoft",
                              "id.microsoft", "id.lucene", "ga.lucene", "it.microsoft", "it.lucene",
                              "ja.microsoft", "ja.lucene", "kn.microsoft", "ko.microsoft", "ko.lucene",
                              "lv.microsoft", "lv.lucene", "lt.microsoft", "ml.microsoft",
                              "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene", "fa.lucene",
                              "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                              "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft",
                              "ro.lucene", "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft",
                              "sr-latin.microsoft", "sk.microsoft", "sl.microsoft", "es.microsoft",
                              "es.lucene", "sv.microsoft", "sv.lucene", "ta.microsoft", "te.microsoft",
                              "th.microsoft", "th.lucene", "tr.microsoft", "tr.lucene", "uk.microsoft",
                              "ur.microsoft", "vi.microsoft", "standard.lucene",
                              "standardasciifolding.lucene", "keyword", "pattern", "simple", "stop",
                              and "whitespace".
                            "facetable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in facet queries. Typically used in a
                              presentation of search results that includes hit count by category (for
                              example, search for digital cameras and see hits by brand, by megapixels,
                              by price, and so on). This property must be null for complex fields.
                              Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint)
                              cannot be facetable. Default is true for all other simple fields.
                            "fields": [
                                ...
                            ],
                            "filterable": bool,  # Optional. A value indicating whether
                              to enable the field to be referenced in $filter queries. filterable
                              differs from searchable in how strings are handled. Fields of type
                              Edm.String or Collection(Edm.String) that are filterable do not undergo
                              word-breaking, so comparisons are for exact matches only. For example, if
                              you set such a field f to "sunny day", $filter=f eq 'sunny' will find no
                              matches, but $filter=f eq 'sunny day' will. This property must be null
                              for complex fields. Default is true for simple fields and null for
                              complex fields.
                            "indexAnalyzer": "str",  # Optional. The name of the analyzer
                              used at indexing time for the field. This option can be used only with
                              searchable fields. It must be set together with searchAnalyzer and it
                              cannot be set together with the analyzer option.  This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. Once the analyzer is chosen, it cannot
                              be changed for the field. Must be null for complex fields. Known values
                              are: "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft",
                              "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "key": bool,  # Optional. A value indicating whether the
                              field uniquely identifies documents in the index. Exactly one top-level
                              field in each index must be chosen as the key field and it must be of
                              type Edm.String. Key fields can be used to look up documents directly and
                              update or delete specific documents. Default is false for simple fields
                              and null for complex fields.
                            "normalizer": "str",  # Optional. The name of the normalizer
                              to use for the field. This option can be used only with fields with
                              filterable, sortable, or facetable enabled. Once the normalizer is
                              chosen, it cannot be changed for the field. Must be null for complex
                              fields. Known values are: "asciifolding", "elision", "lowercase",
                              "standard", and "uppercase".
                            "retrievable": bool,  # Optional. A value indicating whether
                              the field can be returned in a search result. You can disable this option
                              if you want to use a field (for example, margin) as a filter, sorting, or
                              scoring mechanism but do not want the field to be visible to the end
                              user. This property must be true for key fields, and it must be null for
                              complex fields. This property can be changed on existing fields. Enabling
                              this property does not cause any increase in index storage requirements.
                              Default is true for simple fields and null for complex fields.
                            "searchAnalyzer": "str",  # Optional. The name of the
                              analyzer used at search time for the field. This option can be used only
                              with searchable fields. It must be set together with indexAnalyzer and it
                              cannot be set together with the analyzer option. This property cannot be
                              set to the name of a language analyzer; use the analyzer property instead
                              if you need a language analyzer. This analyzer can be updated on an
                              existing field. Must be null for complex fields. Known values are:
                              "ar.microsoft", "ar.lucene", "hy.lucene", "bn.microsoft", "eu.lucene",
                              "bg.microsoft", "bg.lucene", "ca.microsoft", "ca.lucene",
                              "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                              "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene",
                              "da.microsoft", "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft",
                              "en.lucene", "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft",
                              "fr.lucene", "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft",
                              "el.lucene", "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene",
                              "hu.microsoft", "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene",
                              "ga.lucene", "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene",
                              "kn.microsoft", "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene",
                              "lt.microsoft", "ml.microsoft", "ms.microsoft", "mr.microsoft",
                              "nb.microsoft", "no.lucene", "fa.lucene", "pl.microsoft", "pl.lucene",
                              "pt-BR.microsoft", "pt-BR.lucene", "pt-PT.microsoft", "pt-PT.lucene",
                              "pa.microsoft", "ro.microsoft", "ro.lucene", "ru.microsoft", "ru.lucene",
                              "sr-cyrillic.microsoft", "sr-latin.microsoft", "sk.microsoft",
                              "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft", "sv.lucene",
                              "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                              "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft",
                              "vi.microsoft", "standard.lucene", "standardasciifolding.lucene",
                              "keyword", "pattern", "simple", "stop", and "whitespace".
                            "searchable": bool,  # Optional. A value indicating whether
                              the field is full-text searchable. This means it will undergo analysis
                              such as word-breaking during indexing. If you set a searchable field to a
                              value like "sunny day", internally it will be split into the individual
                              tokens "sunny" and "day". This enables full-text searches for these
                              terms. Fields of type Edm.String or Collection(Edm.String) are searchable
                              by default. This property must be false for simple fields of other
                              non-string data types, and it must be null for complex fields. Note:
                              searchable fields consume extra space in your index since Azure Cognitive
                              Search will store an additional tokenized version of the field value for
                              full-text searches. If you want to save space in your index and you don't
                              need a field to be included in searches, set searchable to false.
                            "sortable": bool,  # Optional. A value indicating whether to
                              enable the field to be referenced in $orderby expressions. By default
                              Azure Cognitive Search sorts results by score, but in many experiences
                              users will want to sort by fields in the documents. A simple field can be
                              sortable only if it is single-valued (it has a single value in the scope
                              of the parent document). Simple collection fields cannot be sortable,
                              since they are multi-valued. Simple sub-fields of complex collections are
                              also multi-valued, and therefore cannot be sortable. This is true whether
                              it's an immediate parent field, or an ancestor field, that's the complex
                              collection. Complex fields cannot be sortable and the sortable property
                              must be null for such fields. The default for sortable is true for
                              single-valued simple fields, false for multi-valued simple fields, and
                              null for complex fields.
                            "synonymMaps": [
                                "str"  # Optional. A list of the names of synonym
                                  maps to associate with this field. This option can be used only with
                                  searchable fields. Currently only one synonym map per field is
                                  supported. Assigning a synonym map to a field ensures that query
                                  terms targeting that field are expanded at query-time using the rules
                                  in the synonym map. This attribute can be changed on existing fields.
                                  Must be null or an empty collection for complex fields.
                            ]
                        }
                    ],
                    "name": "str",  # The name of the index. Required.
                    "@odata.etag": "str",  # Optional. The ETag of the index.
                    "analyzers": [
                        lexical_analyzer
                    ],
                    "charFilters": [
                        char_filter
                    ],
                    "corsOptions": {
                        "allowedOrigins": [
                            "str"  # The list of origins from which JavaScript code will
                              be granted access to your index. Can contain a list of hosts of the form
                              {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to
                              allow all origins (not recommended). Required.
                        ],
                        "maxAgeInSeconds": 0  # Optional. The duration for which browsers
                          should cache CORS preflight responses. Defaults to 5 minutes.
                    },
                    "defaultScoringProfile": "str",  # Optional. The name of the scoring profile
                      to use if none is specified in the query. If this property is not set and no
                      scoring profile is specified in the query, then default scoring (tf-idf) will be
                      used.
                    "encryptionKey": {
                        "keyVaultKeyName": "str",  # The name of your Azure Key Vault key to
                          be used to encrypt your data at rest. Required.
                        "keyVaultKeyVersion": "str",  # The version of your Azure Key Vault
                          key to be used to encrypt your data at rest. Required.
                        "keyVaultUri": "str",  # The URI of your Azure Key Vault, also
                          referred to as DNS name, that contains the key to be used to encrypt your
                          data at rest. An example URI might be
                          https://my-keyvault-name.vault.azure.net. Required.
                        "accessCredentials": {
                            "applicationId": "str",  # An AAD Application ID that was
                              granted the required access permissions to the Azure Key Vault that is to
                              be used when encrypting your data at rest. The Application ID should not
                              be confused with the Object ID for your AAD Application. Required.
                            "applicationSecret": "str"  # Optional. The authentication
                              key of the specified AAD application.
                        },
                        "identity": search_indexer_data_identity
                    },
                    "normalizers": [
                        lexical_normalizer
                    ],
                    "scoringProfiles": [
                        {
                            "name": "str",  # The name of the scoring profile. Required.
                            "functionAggregation": "str",  # Optional. A value indicating
                              how the results of individual scoring functions should be combined.
                              Defaults to "Sum". Ignored if there are no scoring functions. Known
                              values are: "sum", "average", "minimum", "maximum", and "firstMatching".
                            "functions": [
                                scoring_function
                            ],
                            "text": {
                                "weights": {
                                    "str": 0.0  # The dictionary of per-field
                                      weights to boost document scoring. The keys are field names and
                                      the values are the weights for each field. Required.
                                }
                            }
                        }
                    ],
                    "semantic": {
                        "configurations": [
                            {
                                "name": "str",  # The name of the semantic
                                  configuration. Required.
                                "prioritizedFields": {
                                    "prioritizedContentFields": [
                                        {
                                            "fieldName": "str"  #
                                              Optional. Defines the content fields to be used for
                                              semantic ranking, captions, highlights, and answers. For
                                              the best result, the selected fields should contain text
                                              in natural language form. The order of the fields in the
                                              array represents their priority. Fields with lower
                                              priority may get truncated if the content is long.
                                        }
                                    ],
                                    "prioritizedKeywordsFields": [
                                        {
                                            "fieldName": "str"  #
                                              Optional. Defines the keyword fields to be used for
                                              semantic ranking, captions, highlights, and answers. For
                                              the best result, the selected fields should contain a
                                              list of keywords. The order of the fields in the array
                                              represents their priority. Fields with lower priority may
                                              get truncated if the content is long.
                                        }
                                    ],
                                    "titleField": {
                                        "fieldName": "str"  # Optional.
                                          Defines the title field to be used for semantic ranking,
                                          captions, highlights, and answers. If you don't have a title
                                          field in your index, leave this blank.
                                    }
                                }
                            }
                        ]
                    },
                    "similarity": similarity,
                    "suggesters": [
                        {
                            "name": "str",  # The name of the suggester. Required.
                            "searchMode": "analyzingInfixMatching",  # Default value is
                              "analyzingInfixMatching". A value indicating the capabilities of the
                              suggester. Required.
                            "sourceFields": [
                                "str"  # The list of field names to which the
                                  suggester applies. Each field must be searchable. Required.
                            ]
                        }
                    ],
                    "tokenFilters": [
                        token_filter
                    ],
                    "tokenizers": [
                        lexical_tokenizer
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_indexes_get_request(
            index_name=index_name,
            x_ms_client_request_id=x_ms_client_request_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def get_statistics(
        self, index_name: str, *, x_ms_client_request_id: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Returns statistics for the given index, including a document count and storage usage.

        :param index_name: The name of the index for which to retrieve statistics. Required.
        :type index_name: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "documentCount": 0,  # The number of documents in the index. Required.
                    "storageSize": 0  # The amount of storage in bytes consumed by the index.
                      Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_indexes_get_statistics_request(
            index_name=index_name,
            x_ms_client_request_id=x_ms_client_request_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def analyze(
        self,
        index_name: str,
        request: JSON,
        *,
        x_ms_client_request_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Shows how an analyzer breaks text into tokens.

        :param index_name: The name of the index for which to test an analyzer. Required.
        :type index_name: str
        :param request: The text and analyzer or analysis components to test. Required.
        :type request: JSON
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                request = {
                    "text": "str",  # The text to break into tokens. Required.
                    "analyzer": "str",  # Optional. The name of the analyzer to use to break the
                      given text. Known values are: "ar.microsoft", "ar.lucene", "hy.lucene",
                      "bn.microsoft", "eu.lucene", "bg.microsoft", "bg.lucene", "ca.microsoft",
                      "ca.lucene", "zh-Hans.microsoft", "zh-Hans.lucene", "zh-Hant.microsoft",
                      "zh-Hant.lucene", "hr.microsoft", "cs.microsoft", "cs.lucene", "da.microsoft",
                      "da.lucene", "nl.microsoft", "nl.lucene", "en.microsoft", "en.lucene",
                      "et.microsoft", "fi.microsoft", "fi.lucene", "fr.microsoft", "fr.lucene",
                      "gl.lucene", "de.microsoft", "de.lucene", "el.microsoft", "el.lucene",
                      "gu.microsoft", "he.microsoft", "hi.microsoft", "hi.lucene", "hu.microsoft",
                      "hu.lucene", "is.microsoft", "id.microsoft", "id.lucene", "ga.lucene",
                      "it.microsoft", "it.lucene", "ja.microsoft", "ja.lucene", "kn.microsoft",
                      "ko.microsoft", "ko.lucene", "lv.microsoft", "lv.lucene", "lt.microsoft",
                      "ml.microsoft", "ms.microsoft", "mr.microsoft", "nb.microsoft", "no.lucene",
                      "fa.lucene", "pl.microsoft", "pl.lucene", "pt-BR.microsoft", "pt-BR.lucene",
                      "pt-PT.microsoft", "pt-PT.lucene", "pa.microsoft", "ro.microsoft", "ro.lucene",
                      "ru.microsoft", "ru.lucene", "sr-cyrillic.microsoft", "sr-latin.microsoft",
                      "sk.microsoft", "sl.microsoft", "es.microsoft", "es.lucene", "sv.microsoft",
                      "sv.lucene", "ta.microsoft", "te.microsoft", "th.microsoft", "th.lucene",
                      "tr.microsoft", "tr.lucene", "uk.microsoft", "ur.microsoft", "vi.microsoft",
                      "standard.lucene", "standardasciifolding.lucene", "keyword", "pattern", "simple",
                      "stop", and "whitespace".
                    "charFilters": [
                        "str"  # Optional. An optional list of character filters to use when
                          breaking the given text.
                    ],
                    "normalizer": "str",  # Optional. The name of the normalizer to use to
                      normalize the given text. Known values are: "asciifolding", "elision",
                      "lowercase", "standard", and "uppercase".
                    "tokenFilters": [
                        "str"  # Optional. An optional list of token filters to use when
                          breaking the given text.
                    ],
                    "tokenizer": "str"  # Optional. The name of the tokenizer to use to break the
                      given text. Known values are: "classic", "edgeNGram", "keyword_v2", "letter",
                      "lowercase", "microsoft_language_tokenizer",
                      "microsoft_language_stemming_tokenizer", "nGram", "path_hierarchy_v2", "pattern",
                      "standard_v2", "uax_url_email", and "whitespace".
                }

                # response body for status code(s): 200
                response == {
                    "tokens": [
                        {
                            "endOffset": 0,  # The index of the last character of the
                              token in the input text. Required.
                            "position": 0,  # The position of the token in the input text
                              relative to other tokens. The first token in the input text has position
                              0, the next has position 1, and so on. Depending on the analyzer used,
                              some tokens might have the same position, for example if they are
                              synonyms of each other. Required.
                            "startOffset": 0,  # The index of the first character of the
                              token in the input text. Required.
                            "token": "str"  # The token returned by the analyzer.
                              Required.
                        }
                    ]
                }
        """

    @overload
    async def analyze(
        self,
        index_name: str,
        request: IO,
        *,
        x_ms_client_request_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Shows how an analyzer breaks text into tokens.

        :param index_name: The name of the index for which to test an analyzer. Required.
        :type index_name: str
        :param request: The text and analyzer or analysis components to test. Required.
        :type request: IO
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "tokens": [
                        {
                            "endOffset": 0,  # The index of the last character of the
                              token in the input text. Required.
                            "position": 0,  # The position of the token in the input text
                              relative to other tokens. The first token in the input text has position
                              0, the next has position 1, and so on. Depending on the analyzer used,
                              some tokens might have the same position, for example if they are
                              synonyms of each other. Required.
                            "startOffset": 0,  # The index of the first character of the
                              token in the input text. Required.
                            "token": "str"  # The token returned by the analyzer.
                              Required.
                        }
                    ]
                }
        """

    @distributed_trace_async
    async def analyze(
        self, index_name: str, request: Union[JSON, IO], *, x_ms_client_request_id: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Shows how an analyzer breaks text into tokens.

        :param index_name: The name of the index for which to test an analyzer. Required.
        :type index_name: str
        :param request: The text and analyzer or analysis components to test. Is either a model type or
         a IO type. Required.
        :type request: JSON or IO
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "tokens": [
                        {
                            "endOffset": 0,  # The index of the last character of the
                              token in the input text. Required.
                            "position": 0,  # The position of the token in the input text
                              relative to other tokens. The first token in the input text has position
                              0, the next has position 1, and so on. Depending on the analyzer used,
                              some tokens might have the same position, for example if they are
                              synonyms of each other. Required.
                            "startOffset": 0,  # The index of the first character of the
                              token in the input text. Required.
                            "token": "str"  # The token returned by the analyzer.
                              Required.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(request, (IO, bytes)):
            _content = request
        else:
            _json = request

        request = build_indexes_analyze_request(
            index_name=index_name,
            x_ms_client_request_id=x_ms_client_request_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class AliasesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~search_service_client.aio.SearchServiceClient`'s
        :attr:`aliases` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def create(
        self,
        alias: JSON,
        *,
        x_ms_client_request_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new search alias.

        :param alias: The definition of the alias to create. Required.
        :type alias: JSON
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                alias = {
                    "indexes": [
                        "str"  # The name of the index this alias maps to. Only one index
                          name may be specified. Required.
                    ],
                    "name": "str",  # The name of the alias. Required.
                    "@odata.etag": "str"  # Optional. The ETag of the alias.
                }

                # response body for status code(s): 201
                response == {
                    "indexes": [
                        "str"  # The name of the index this alias maps to. Only one index
                          name may be specified. Required.
                    ],
                    "name": "str",  # The name of the alias. Required.
                    "@odata.etag": "str"  # Optional. The ETag of the alias.
                }
        """

    @overload
    async def create(
        self,
        alias: IO,
        *,
        x_ms_client_request_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new search alias.

        :param alias: The definition of the alias to create. Required.
        :type alias: IO
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "indexes": [
                        "str"  # The name of the index this alias maps to. Only one index
                          name may be specified. Required.
                    ],
                    "name": "str",  # The name of the alias. Required.
                    "@odata.etag": "str"  # Optional. The ETag of the alias.
                }
        """

    @distributed_trace_async
    async def create(
        self, alias: Union[JSON, IO], *, x_ms_client_request_id: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Creates a new search alias.

        :param alias: The definition of the alias to create. Is either a model type or a IO type.
         Required.
        :type alias: JSON or IO
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "indexes": [
                        "str"  # The name of the index this alias maps to. Only one index
                          name may be specified. Required.
                    ],
                    "name": "str",  # The name of the alias. Required.
                    "@odata.etag": "str"  # Optional. The ETag of the alias.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(alias, (IO, bytes)):
            _content = alias
        else:
            _json = alias

        request = build_aliases_create_request(
            x_ms_client_request_id=x_ms_client_request_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def list(self, *, x_ms_client_request_id: Optional[str] = None, **kwargs: Any) -> AsyncIterable[JSON]:
        """Lists all aliases available for a search service.

        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "indexes": [
                        "str"  # The name of the index this alias maps to. Only one index
                          name may be specified. Required.
                    ],
                    "name": "str",  # The name of the alias. Required.
                    "@odata.etag": "str"  # Optional. The ETag of the alias.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_aliases_list_request(
                    x_ms_client_request_id=x_ms_client_request_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.endpoint", self._config.endpoint, "str", skip_quote=True
                    ),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @overload
    async def create_or_update(
        self,
        alias_name: str,
        alias: JSON,
        *,
        prefer: str,
        x_ms_client_request_id: Optional[str] = None,
        if_match: Optional[str] = None,
        if_none_match: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new search alias or updates an alias if it already exists.

        :param alias_name: The definition of the alias to create or update. Required.
        :type alias_name: str
        :param alias: The definition of the alias to create or update. Required.
        :type alias: JSON
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword if_match: Defines the If-Match condition. The operation will be performed only if the
         ETag on the server matches this value. Default value is None.
        :paramtype if_match: str
        :keyword if_none_match: Defines the If-None-Match condition. The operation will be performed
         only if the ETag on the server does not match this value. Default value is None.
        :paramtype if_none_match: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                alias = {
                    "indexes": [
                        "str"  # The name of the index this alias maps to. Only one index
                          name may be specified. Required.
                    ],
                    "name": "str",  # The name of the alias. Required.
                    "@odata.etag": "str"  # Optional. The ETag of the alias.
                }

                # response body for status code(s): 200, 201
                response == {
                    "indexes": [
                        "str"  # The name of the index this alias maps to. Only one index
                          name may be specified. Required.
                    ],
                    "name": "str",  # The name of the alias. Required.
                    "@odata.etag": "str"  # Optional. The ETag of the alias.
                }
        """

    @overload
    async def create_or_update(
        self,
        alias_name: str,
        alias: IO,
        *,
        prefer: str,
        x_ms_client_request_id: Optional[str] = None,
        if_match: Optional[str] = None,
        if_none_match: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Creates a new search alias or updates an alias if it already exists.

        :param alias_name: The definition of the alias to create or update. Required.
        :type alias_name: str
        :param alias: The definition of the alias to create or update. Required.
        :type alias: IO
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword if_match: Defines the If-Match condition. The operation will be performed only if the
         ETag on the server matches this value. Default value is None.
        :paramtype if_match: str
        :keyword if_none_match: Defines the If-None-Match condition. The operation will be performed
         only if the ETag on the server does not match this value. Default value is None.
        :paramtype if_none_match: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "indexes": [
                        "str"  # The name of the index this alias maps to. Only one index
                          name may be specified. Required.
                    ],
                    "name": "str",  # The name of the alias. Required.
                    "@odata.etag": "str"  # Optional. The ETag of the alias.
                }
        """

    @distributed_trace_async
    async def create_or_update(
        self,
        alias_name: str,
        alias: Union[JSON, IO],
        *,
        prefer: str,
        x_ms_client_request_id: Optional[str] = None,
        if_match: Optional[str] = None,
        if_none_match: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """Creates a new search alias or updates an alias if it already exists.

        :param alias_name: The definition of the alias to create or update. Required.
        :type alias_name: str
        :param alias: The definition of the alias to create or update. Is either a model type or a IO
         type. Required.
        :type alias: JSON or IO
        :keyword prefer: For HTTP PUT requests, instructs the service to return the created/updated
         resource on success. "return=representation" Required.
        :paramtype prefer: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword if_match: Defines the If-Match condition. The operation will be performed only if the
         ETag on the server matches this value. Default value is None.
        :paramtype if_match: str
        :keyword if_none_match: Defines the If-None-Match condition. The operation will be performed
         only if the ETag on the server does not match this value. Default value is None.
        :paramtype if_none_match: str
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "indexes": [
                        "str"  # The name of the index this alias maps to. Only one index
                          name may be specified. Required.
                    ],
                    "name": "str",  # The name of the alias. Required.
                    "@odata.etag": "str"  # Optional. The ETag of the alias.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(alias, (IO, bytes)):
            _content = alias
        else:
            _json = alias

        request = build_aliases_create_or_update_request(
            alias_name=alias_name,
            prefer=prefer,
            x_ms_client_request_id=x_ms_client_request_id,
            if_match=if_match,
            if_none_match=if_none_match,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def delete(  # pylint: disable=inconsistent-return-statements
        self,
        alias_name: str,
        *,
        x_ms_client_request_id: Optional[str] = None,
        if_match: Optional[str] = None,
        if_none_match: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """Deletes a search alias and its associated mapping to an index. This operation is permanent,
        with no recovery option. The mapped index is untouched by this operation.

        :param alias_name: The name of the alias to delete. Required.
        :type alias_name: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :keyword if_match: Defines the If-Match condition. The operation will be performed only if the
         ETag on the server matches this value. Default value is None.
        :paramtype if_match: str
        :keyword if_none_match: Defines the If-None-Match condition. The operation will be performed
         only if the ETag on the server does not match this value. Default value is None.
        :paramtype if_none_match: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_aliases_delete_request(
            alias_name=alias_name,
            x_ms_client_request_id=x_ms_client_request_id,
            if_match=if_match,
            if_none_match=if_none_match,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace_async
    async def get(self, alias_name: str, *, x_ms_client_request_id: Optional[str] = None, **kwargs: Any) -> JSON:
        """Retrieves an alias definition.

        :param alias_name: The name of the alias to retrieve. Required.
        :type alias_name: str
        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "indexes": [
                        "str"  # The name of the index this alias maps to. Only one index
                          name may be specified. Required.
                    ],
                    "name": "str",  # The name of the alias. Required.
                    "@odata.etag": "str"  # Optional. The ETag of the alias.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_aliases_get_request(
            alias_name=alias_name,
            x_ms_client_request_id=x_ms_client_request_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class SearchServiceClientOperationsMixin(SearchServiceClientMixinABC):
    @distributed_trace_async
    async def get_service_statistics(self, *, x_ms_client_request_id: Optional[str] = None, **kwargs: Any) -> JSON:
        """Gets service level statistics for a search service.

        :keyword x_ms_client_request_id: The tracking ID sent with the request to help with debugging.
         Default value is None.
        :paramtype x_ms_client_request_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "counters": {
                        "dataSourcesCount": {
                            "usage": 0,  # The resource usage amount. Required.
                            "quota": 0  # Optional. The resource amount quota.
                        },
                        "documentCount": {
                            "usage": 0,  # The resource usage amount. Required.
                            "quota": 0  # Optional. The resource amount quota.
                        },
                        "indexersCount": {
                            "usage": 0,  # The resource usage amount. Required.
                            "quota": 0  # Optional. The resource amount quota.
                        },
                        "indexesCount": {
                            "usage": 0,  # The resource usage amount. Required.
                            "quota": 0  # Optional. The resource amount quota.
                        },
                        "storageSize": {
                            "usage": 0,  # The resource usage amount. Required.
                            "quota": 0  # Optional. The resource amount quota.
                        },
                        "synonymMaps": {
                            "usage": 0,  # The resource usage amount. Required.
                            "quota": 0  # Optional. The resource amount quota.
                        },
                        "aliasesCount": {
                            "usage": 0,  # The resource usage amount. Required.
                            "quota": 0  # Optional. The resource amount quota.
                        },
                        "skillsetCount": {
                            "usage": 0,  # The resource usage amount. Required.
                            "quota": 0  # Optional. The resource amount quota.
                        }
                    },
                    "limits": {
                        "maxComplexCollectionFieldsPerIndex": 0,  # Optional. The maximum
                          number of fields of type Collection(Edm.ComplexType) allowed in an index.
                        "maxComplexObjectsInCollectionsPerDocument": 0,  # Optional. The
                          maximum number of objects in complex collections allowed per document.
                        "maxFieldNestingDepthPerIndex": 0,  # Optional. The maximum depth
                          which you can nest sub-fields in an index, including the top-level complex
                          field. For example, a/b/c has a nesting depth of 3.
                        "maxFieldsPerIndex": 0  # Optional. The maximum allowed fields per
                          index.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_search_service_get_service_statistics_request(
            x_ms_client_request_id=x_ms_client_request_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)
